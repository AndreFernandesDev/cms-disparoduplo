"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscriptionStore = void 0;
const store_1 = require("svelte/store");
// locals
const cache_1 = __importDefault(require("../cache"));
const lib_1 = require("../lib");
const network_1 = require("../lib/network");
const scalars_1 = require("../lib/scalars");
function subscriptionStore({ config, artifact, }) {
    // a store that holds the latest value
    const result = (0, store_1.writable)(null);
    // @ts-expect-error: typechecking cjs/esm interop is hard
    // pull the query text out of the compiled artifact
    const { raw: text, selection } = artifact.default || artifact;
    // the function to call to unregister the subscription
    let clearSubscription = () => { };
    // listen might be called multiple times while mounted
    let lastVariables = null;
    return {
        name: artifact.name,
        subscribe: result.subscribe,
        listen(variables) {
            // pull out the current client
            const env = (0, network_1.getCurrentClient)();
            // if there isn't one, yell loudly
            if (!env) {
                throw new Error('Could not find Houdini Client');
            }
            // we need to make sure that the user provided a socket connection
            if (!env.socket) {
                throw new Error('The current Houdini Client is not configured to handle subscriptions. Make sure you ' +
                    'passed a socketClient to HoudiniClient constructor.');
            }
            // marshal the inputs into their raw values
            const marshaledVariables = (0, scalars_1.marshalInputs)({
                input: variables || {},
                config,
                artifact,
            });
            // if the variables haven't changed, don't do anything
            if ((0, lib_1.deepEquals)(lastVariables, marshaledVariables)) {
                return;
            }
            // clear any existing subscription
            clearSubscription();
            // save the last set
            lastVariables = marshaledVariables;
            // start listening for updates from the server
            clearSubscription = env.socket.subscribe({
                query: text,
                variables: marshaledVariables,
            }, {
                next({ data, errors }) {
                    // make sure there were no errors
                    if (errors) {
                        throw errors;
                    }
                    // if we got a result
                    if (data) {
                        // update the cache with the result
                        cache_1.default.write({
                            selection,
                            data,
                            variables: marshaledVariables,
                        });
                        // update the local store
                        result.set((0, scalars_1.unmarshalSelection)(config, artifact.selection, data));
                    }
                },
                error(data) { },
                complete() { },
            });
        },
        unlisten() {
            clearSubscription();
            clearSubscription = () => { };
            lastVariables = null;
        },
    };
}
exports.subscriptionStore = subscriptionStore;
