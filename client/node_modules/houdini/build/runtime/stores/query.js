"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryStore = void 0;
// externals
const store_1 = require("svelte/store");
// internals
const __1 = require("..");
const adapter_1 = require("../adapter");
const cache_1 = __importDefault(require("../cache"));
const lib_1 = require("../lib");
const context_1 = require("../lib/context");
const pagination_1 = require("../lib/pagination");
const scalars_1 = require("../lib/scalars");
const log = __importStar(require("../lib/log"));
// Terms:
// - CSF: client side fetch. identified by a lack of loadEvent
//
// Notes:
// - load handles prefetch and server-side
//   - If the incoming variables on a load are different than the tracker, don't write to the store
// - load only populates the store on the server
// - load should _always_ perform a fetchAndCache
//   - it's guaranteed to run before the CSF because the change in variables is what triggers the CSF
//     - data won't necessarily be in the cache since blocking could be set to false
//
// - CSF must load the data aswell (pre-fetches don't get another invocation of load())
// - CSF must manage subscriptions
// - CSF must update variable tracker.
// - CSF might happen when load is also firing
//   - avoid the double request
//   - still need to subscribe to data
//
function queryStore({ config, artifact, storeName, paginationMethods, paginated, }) {
    // only include pageInfo in the store state if the query is paginated
    const initialState = () => ({
        data: null,
        errors: null,
        isFetching: false,
        partial: false,
        source: null,
        variables: null,
    });
    // at its core, a query store is a writable store with extra methods
    const store = (0, store_1.writable)(initialState());
    const setFetching = (isFetching) => store.update((s) => ({ ...s, isFetching }));
    const getVariables = () => (0, store_1.get)(store).variables;
    // the first client-side request after the mocked load() needs to be blocked
    let blockNextCSF = false;
    // we will be reading and write the last known variables often, avoid frequent gets and updates
    let lastVariables = null;
    // track the subscription's existence to refresh and unsubscribe when unmounting
    let subscriptionSpec = null;
    // if there is a load in progress when the CSF triggers we need to stop it
    let loadPending = false;
    // a function to update the store's cache subscriptions
    function refreshSubscription(newVariables) {
        // if the variables changed we need to unsubscribe from the old fields and
        // listen to the new ones
        if (subscriptionSpec) {
            cache_1.default.unsubscribe(subscriptionSpec, lastVariables || {});
        }
        // subscribe to cache updates
        subscriptionSpec = {
            rootType: artifact.rootType,
            selection: artifact.selection,
            variables: () => newVariables,
            set: (data) => store.update((s) => ({ ...s, data })),
        };
        // make sure we subscribe to the new values
        cache_1.default.subscribe(subscriptionSpec, newVariables);
        // track the newVariables
        lastVariables = newVariables;
    }
    // a function to fetch data (the root of the behavior tree described above)
    async function fetch(args) {
        // validate and prepare the request context for the current environment (client vs server)
        const { context, policy, params } = fetchContext(artifact, storeName, args);
        // identify if this is a CSF or load
        const isLoadFetch = Boolean(params?.event);
        const isComponentFetch = !isLoadFetch;
        // compute the variables we need to use for the query
        const input = ((0, scalars_1.marshalInputs)({
            artifact,
            config,
            input: params?.variables,
        }) || {});
        const newVariables = {
            ...lastVariables,
            ...input,
        };
        // check if the variables are different from the last time we saw them
        let variableChange = !(0, lib_1.deepEquals)(lastVariables, newVariables);
        // detect if there is a load function that fires before the first CSF
        if (isLoadFetch && lastVariables === null && Boolean(args?.event)) {
            blockNextCSF = true;
        }
        // if we are loading on the client and the variables _are_ different, we have to
        // update the subscribers. do that before the fetch so we don't accidentally
        // cause the new data to trigger the old subscription after the store has been
        // update with fetchAndCache
        if (isComponentFetch && variableChange) {
            refreshSubscription(newVariables);
        }
        // if there is a pending load, don't do anything
        if (loadPending && isComponentFetch) {
            // if the variables haven't changed and we dont have an active subscription
            // then we need to start listening
            if (!variableChange && subscriptionSpec === null) {
                refreshSubscription(newVariables);
            }
            return (0, store_1.get)(store);
        }
        if (isComponentFetch) {
            // a component fetch is _always_ blocking
            params.blocking = true;
        }
        // the fetch is happening in a load
        if (isLoadFetch) {
            loadPending = true;
        }
        // there are a few cases where the CSF needs to be prevented:
        // - the last request was from a server-side rendered request (faked by svelte kit)
        // - the variables didn't change and we're not being forced to request it
        // - there is a pending load function
        if (isComponentFetch &&
            (blockNextCSF ||
                (!variableChange && params.policy !== __1.CachePolicy.NetworkOnly) ||
                loadPending)) {
            blockNextCSF = false;
            // if the variables didn't change, get the latest value and use that
            if (!variableChange) {
                await fetchAndCache({
                    config,
                    context,
                    artifact,
                    variables: newVariables,
                    store,
                    updateStore: true,
                    cached: true,
                    policy: __1.CachePolicy.CacheOnly,
                    setLoadPending: (val) => {
                        loadPending = val;
                        setFetching(val);
                    },
                });
            }
            // if we dont have a subscription but we're ending early we need to listen for
            // changes
            if (subscriptionSpec === null) {
                refreshSubscription(newVariables);
            }
            // make sure we return before the fetch happens
            return (0, store_1.get)(store);
        }
        // we want to update the store in four situations: ssr, csf, the first load of the ssr response,
        // or if we got this far and the variables haven't changed (avoid prefetch)
        const updateStore = !adapter_1.isBrowser ||
            isComponentFetch ||
            (lastVariables === null && variableChange) ||
            !variableChange;
        // we might not want to wait for the fetch to resolve
        const fakeAwait = adapter_1.clientStarted && adapter_1.isBrowser && !params?.blocking;
        setFetching(true);
        // perform the network request
        const request = fetchAndCache({
            config,
            context,
            artifact,
            variables: newVariables,
            store,
            updateStore,
            cached: policy !== __1.CachePolicy.NetworkOnly,
            setLoadPending: (val) => {
                loadPending = val;
                setFetching(val);
            },
        });
        // if we weren't told to block we're done (only valid for a client-side request)
        if (fakeAwait) {
            return (0, store_1.get)(store);
        }
        // if we got this far, we need to wait for the response from the request
        await request;
        // the store will have been updated already since we waited for the response
        return (0, store_1.get)(store);
    }
    // we might need to mix multiple store values for the user
    const relevantStores = [store];
    // add the pagination methods to the store
    let extraMethods = {};
    if (paginated) {
        const handlers = (0, pagination_1.queryHandlers)({
            config,
            artifact,
            store: {
                name: artifact.name,
                subscribe: store.subscribe,
                async fetch(params) {
                    return (await fetch({
                        ...params,
                        blocking: true,
                    }));
                },
            },
            queryVariables: getVariables,
        });
        // we only want to add page info if we have to
        relevantStores.push((0, store_1.derived)([handlers.pageInfo], ([pageInfo]) => ({ pageInfo })));
        extraMethods = Object.fromEntries(Object.entries(paginationMethods).map(([key, value]) => [key, handlers[value]]));
    }
    // mix any of the stores we care about
    const userFacingStore = (0, store_1.derived)(relevantStores, (stores) => Object.assign({}, ...stores));
    return {
        name: artifact.name,
        subscribe: (...args) => {
            const bubbleUp = userFacingStore.subscribe(...args);
            // Handle unsubscribe
            return () => {
                // clean up any cache subscriptions
                if (subscriptionSpec) {
                    cache_1.default.unsubscribe(subscriptionSpec, lastVariables || {});
                    subscriptionSpec = null;
                }
                // clear the variable counter
                lastVariables = null;
                // don't clear the store state on the server (breaks SSR)
                if (adapter_1.isBrowser) {
                    // reset the store value
                    store.set(initialState());
                }
                // we're done
                bubbleUp();
            };
        },
        fetch,
        ...extraMethods,
    };
}
exports.queryStore = queryStore;
function fetchContext(artifact, storeName, params) {
    // if we aren't on the browser but there's no event there's a big mistake
    if (!adapter_1.isBrowser && (!params || !params.event || !params.event.fetch)) {
        // prettier-ignore
        log.error(`
	${log.red(`Missing event args in load function`)}. 

	Two options:
	${log.cyan("1/ Prefetching & SSR")}
  <script context="module" lang="ts">
    import type { LoadEvent } from '@sveltejs/kit';

    export async function load(${log.yellow('event')}: LoadEvent) {
			const variables = { ... };
      await ${log.cyan(storeName)}.fetch({ ${log.yellow('event')}, variables });
      return { props: { variables } };
    }
  </script> 

	<script lang="ts">
		import { type ${log.cyan(storeName)}$input } from '$houdini'
		export let variables: ${log.cyan(storeName)}$input;
		
		$: browser && ${log.cyan(storeName)}.fetch({ variables });
	</script> 

	${log.cyan("2/ Client only")}
	<script lang="ts">
		$: browser && ${log.cyan(storeName)}.fetch({ variables: { ... } });
	</script> 
`);
        throw new Error('Error, check above logs for help.');
    }
    // figure out the right policy
    let policy = params?.policy;
    if (!policy) {
        // use the artifact policy as the default, otherwise prefer the cache over the network
        policy = artifact.policy ?? __1.CachePolicy.CacheOrNetwork;
    }
    // if there is an event (we are inside of a load), the event is a good enough context, otherwise
    // we have to build up a context appropriate for the client
    let context = params?.event;
    if (!context) {
        const houdiniContext = params?.context || (0, context_1.nullHoudiniContext)();
        context = {
            fetch: window.fetch.bind(window),
            session: houdiniContext.session?.(),
            stuff: houdiniContext.stuff || {},
        };
    }
    // Add metadata info to the context
    context = { ...context, metadata: params?.metadata };
    return { context, policy, params: params ?? {} };
}
async function fetchAndCache({ config, context, artifact, variables, store, updateStore, cached, ignoreFollowup, setLoadPending, policy, }) {
    const request = await (0, __1.fetchQuery)({
        config,
        context,
        artifact,
        variables,
        cached,
        policy,
    });
    const { result, source, partial } = request;
    // we're done
    setLoadPending(false);
    if (result.data && source !== __1.DataSource.Cache) {
        // update the cache with the data that we just ran into
        cache_1.default.write({
            selection: artifact.selection,
            data: result.data,
            variables: variables || {},
        });
    }
    if (updateStore) {
        // unmarshal the result into complex scalars if its a response from the server
        const unmarshaled = source === __1.DataSource.Cache
            ? result.data
            : (0, scalars_1.unmarshalSelection)(config, artifact.selection, result.data);
        // since we know we're not prefetching, we need to update the store with any errors
        if (result.errors && result.errors.length > 0) {
            store.update((s) => ({
                ...s,
                errors: result.errors,
                isFetching: false,
                partial: false,
                data: unmarshaled,
                source,
                variables,
            }));
            // don't go any further
            throw result.errors;
        }
        else {
            store.set({
                data: (unmarshaled || {}),
                variables: variables || {},
                errors: null,
                isFetching: false,
                partial: request.partial,
                source: request.source,
            });
        }
    }
    if (!ignoreFollowup) {
        // if the data was loaded from a cached value, and the document cache policy wants a
        // network request to be sent after the data was loaded, load the data
        if (source === __1.DataSource.Cache && artifact.policy === __1.CachePolicy.CacheAndNetwork) {
            fetchAndCache({
                config,
                context,
                artifact,
                variables,
                store,
                cached: false,
                updateStore,
                ignoreFollowup: true,
                setLoadPending,
                policy,
            });
        }
        // if we have a partial result and we can load the rest of the data
        // from the network, send the request
        if (partial && artifact.policy === __1.CachePolicy.CacheOrNetwork) {
            fetchAndCache({
                config,
                context,
                artifact,
                variables,
                store,
                cached: false,
                updateStore,
                ignoreFollowup: true,
                setLoadPending,
                policy,
            });
        }
    }
    return request;
}
