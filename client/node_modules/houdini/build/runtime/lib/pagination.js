"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullPageInfo = exports.countPage = exports.extractPageInfo = exports.queryHandlers = exports.fragmentHandlers = exports.wrapPaginationStore = void 0;
// externals
const store_1 = require("svelte/store");
// locals
const __1 = require("..");
const cache_1 = __importDefault(require("../cache"));
const config_1 = require("./config");
const context_1 = require("./context");
const network_1 = require("./network");
function wrapPaginationStore(store) {
    // @ts-ignore
    const { loadNextPage, loadPreviousPage, ...rest } = store;
    // grab the current houdini context
    const context = (0, context_1.getHoudiniContext)();
    const result = rest;
    if (loadNextPage) {
        // @ts-ignore
        result.loadNextPage = (...args) => loadNextPage(context, ...args);
    }
    if (loadPreviousPage) {
        // @ts-ignore
        result.loadPreviousPage = (...args) => loadPreviousPage(context, ...args);
    }
    return result;
}
exports.wrapPaginationStore = wrapPaginationStore;
function fragmentHandlers({ config, paginationArtifact, initialValue, store, }) {
    const { targetType } = paginationArtifact.refetch || {};
    const typeConfig = config.types?.[targetType || ''];
    if (!typeConfig) {
        throw new Error(`Missing type refetch configuration for ${targetType}. For more information, see https://www.houdinigraphql.com/guides/pagination#paginated-fragments`);
    }
    let queryVariables = () => ({});
    // if the query is embedded we have to figure out the correct variables to pass
    if (paginationArtifact.refetch.embedded) {
        // if we have a specific function to use when computing the variables
        if (typeConfig.resolve?.arguments) {
            queryVariables = () => {
                const value = (0, store_1.get)(store);
                return (typeConfig.resolve.arguments?.(value) || {});
            };
        }
        else {
            const keys = (0, config_1.keyFieldsForType)(config, targetType || '');
            queryVariables = () => {
                const value = (0, store_1.get)(store);
                // @ts-ignore
                return Object.fromEntries(keys.map((key) => [key, value[key]]));
            };
        }
    }
    return paginationHandlers({
        config,
        initialValue,
        store: store,
        artifact: paginationArtifact,
        queryVariables,
        refetch: async () => {
            return {};
        },
    });
}
exports.fragmentHandlers = fragmentHandlers;
function queryHandlers({ config, artifact, store, queryVariables, }) {
    // if there's no refetch config for the artifact there's a problem
    if (!artifact.refetch) {
        throw new Error('paginatedQuery must be passed a query with @paginate.');
    }
    // create some derived stores from the query meta data
    const loading = (0, store_1.derived)([store], ([$store]) => $store.isFetching);
    const data = (0, store_1.derived)([store], ([$store]) => $store.data);
    // return the handlers
    return paginationHandlers({
        documentLoading: loading,
        initialValue: (0, store_1.get)(store).data || {},
        artifact,
        store: data,
        queryVariables,
        refetch: store.fetch,
        config,
    });
}
exports.queryHandlers = queryHandlers;
function paginationHandlers({ initialValue, artifact, store, queryVariables, documentLoading, refetch, config, }) {
    // start with the defaults and no meaningful page info
    let loadPreviousPage = async (...args) => { };
    let loadNextPage = async (...args) => { };
    let pageInfo = (0, store_1.readable)((0, exports.nullPageInfo)());
    // loading state
    let paginationLoadingState = (0, store_1.writable)(false);
    let refetchQuery;
    // if the artifact supports cursor based pagination
    if (artifact.refetch?.method === 'cursor') {
        // generate the cursor handlers
        const cursor = cursorHandlers({
            initialValue,
            artifact,
            store,
            queryVariables,
            loading: paginationLoadingState,
            refetch,
            config,
        });
        // always track pageInfo
        pageInfo = cursor.pageInfo;
        // always use the refetch fn
        refetchQuery = cursor.refetch;
        // if we are implementing forward pagination
        if (artifact.refetch.update === 'append') {
            loadNextPage = cursor.loadNextPage;
        }
        // the artifact implements backwards pagination
        else {
            loadPreviousPage = cursor.loadPreviousPage;
        }
    }
    // the artifact supports offset-based pagination, only loadNextPage is valid
    else {
        const offset = offsetPaginationHandler({
            initialValue,
            artifact,
            queryVariables,
            loading: paginationLoadingState,
            refetch,
            store,
            config,
        });
        loadNextPage = offset.loadPage;
        refetchQuery = offset.refetch;
    }
    // if no loading state was provided just use a store that's always false
    if (!documentLoading) {
        documentLoading = (0, store_1.readable)(false, () => { });
    }
    // merge the pagination and document loading state
    const loading = (0, store_1.derived)([paginationLoadingState, documentLoading], ($loadingStates) => $loadingStates[0] || $loadingStates[1]);
    return { loadNextPage, loadPreviousPage, pageInfo, loading, refetch: refetchQuery };
}
function cursorHandlers({ config, initialValue, artifact, store, queryVariables: extraVariables, loading, refetch, }) {
    // track the current page info in an easy-to-reach store
    const initialPageInfo = extractPageInfo(initialValue, artifact.refetch.path) ?? (0, exports.nullPageInfo)();
    const pageInfo = (0, store_1.writable)(initialPageInfo);
    // hold onto the current value
    let value = initialValue;
    store.subscribe((val) => {
        pageInfo.set(extractPageInfo(val, artifact.refetch.path));
        value = val;
    });
    // dry up the page-loading logic
    const loadPage = async ({ houdiniContext, pageSizeVar, input, functionName, }) => {
        // set the loading state to true
        loading.set(true);
        // build up the variables to pass to the query
        const loadVariables = {
            ...extraVariables?.(),
            ...houdiniContext.variables(),
            ...input,
        };
        // if we don't have a value for the page size, tell the user
        if (!loadVariables[pageSizeVar] && !artifact.refetch.pageSize) {
            throw missingPageSizeError(functionName);
        }
        // send the query
        const { result } = await (0, network_1.executeQuery)({
            artifact,
            variables: loadVariables,
            session: houdiniContext.session?.(),
            cached: false,
            config,
        });
        // if the query is embedded in a node field (paginated fragments)
        // make sure we look down one more for the updated page info
        const resultPath = [...artifact.refetch.path];
        if (artifact.refetch.embedded) {
            const { targetType } = artifact.refetch;
            // make sure we have a type config for the pagination target type
            if (!config.types?.[targetType]?.resolve) {
                throw new Error(`Missing type resolve configuration for ${targetType}. For more information, see https://www.houdinigraphql.com/guides/pagination#paginated-fragments`);
            }
            // make sure that we pull the value out of the correct query field
            resultPath.unshift(config.types[targetType].resolve.queryField);
        }
        // we need to find the connection object holding the current page info
        pageInfo.set(extractPageInfo(result.data, resultPath));
        // update cache with the result
        cache_1.default.write({
            selection: artifact.selection,
            data: result.data,
            variables: loadVariables,
            applyUpdates: true,
        });
        // we're not loading any more
        loading.set(false);
    };
    return {
        loading,
        loadNextPage: async (houdiniContext, pageCount) => {
            // we need to find the connection object holding the current page info
            const currentPageInfo = extractPageInfo(value, artifact.refetch.path);
            // if there is no next page, we're done
            if (!currentPageInfo.hasNextPage) {
                return;
            }
            // only specify the page count if we're given one
            const input = {
                after: currentPageInfo.endCursor,
            };
            if (pageCount) {
                input.first = pageCount;
            }
            // load the page
            return await loadPage({
                houdiniContext,
                pageSizeVar: 'first',
                functionName: 'loadNextPage',
                input,
            });
        },
        loadPreviousPage: async (houdiniContext, pageCount) => {
            // we need to find the connection object holding the current page info
            const currentPageInfo = extractPageInfo(value, artifact.refetch.path);
            // if there is no next page, we're done
            if (!currentPageInfo.hasPreviousPage) {
                return;
            }
            // only specify the page count if we're given one
            const input = {
                before: currentPageInfo.startCursor,
            };
            if (pageCount) {
                input.last = pageCount;
            }
            // load the page
            return await loadPage({
                houdiniContext,
                pageSizeVar: 'last',
                functionName: 'loadPreviousPage',
                input,
            });
        },
        pageInfo: { subscribe: pageInfo.subscribe },
        async refetch(params) {
            const { variables } = params ?? {};
            // build up the variables to pass to the query
            const queryVariables = {
                ...extraVariables(),
                ...variables,
            };
            // if the input is different than the query variables then we just do everything like normal
            if (variables && !(0, __1.deepEquals)(extraVariables(), variables)) {
                return refetch(params);
            }
            // we are updating the current set of items, count the number of items that currently exist
            // and ask for the full data set
            const count = countPage(artifact.refetch.path.concat('edges'), value) ||
                artifact.refetch.pageSize;
            // if there are more records than the first page, we need fetch to load everything
            if (count && count > artifact.refetch.pageSize) {
                // reverse cursors need the last entries in the list
                queryVariables[artifact.refetch.update === 'prepend' ? 'last' : 'first'] = count;
            }
            // set the loading state to true
            loading.set(true);
            // send the query
            const result = await refetch({
                ...params,
                variables: queryVariables,
            });
            // we're not loading any more
            loading.set(false);
            return {
                data: result.data,
                variables: queryVariables,
                isFetching: false,
                partial: result.partial,
                errors: null,
                source: result.source,
            };
        },
    };
}
function offsetPaginationHandler({ artifact, queryVariables: extraVariables, loading, refetch, initialValue, store, config, }) {
    // we need to track the most recent offset for this handler
    let currentOffset = artifact.refetch?.start ||
        countPage(artifact.refetch.path, initialValue) ||
        artifact.refetch.pageSize;
    // hold onto the current value
    let value = initialValue;
    store.subscribe((val) => {
        value = val;
    });
    return {
        loadPage: async (houdiniContext, limit) => {
            // build up the variables to pass to the query
            const queryVariables = {
                ...houdiniContext.variables(),
                ...extraVariables(),
                offset: currentOffset,
            };
            if (limit) {
                queryVariables.limit = limit;
            }
            // if we made it this far without a limit argument and there's no default page size,
            // they made a mistake
            if (!queryVariables.limit && !artifact.refetch.pageSize) {
                throw missingPageSizeError('loadNextPage');
            }
            // set the loading state to true
            loading.set(true);
            // send the query
            const { result } = await (0, network_1.executeQuery)({
                artifact,
                variables: queryVariables,
                session: houdiniContext.session?.(),
                cached: false,
                config,
            });
            // update cache with the result
            cache_1.default.write({
                selection: artifact.selection,
                data: result.data,
                variables: queryVariables,
                applyUpdates: true,
            });
            // add the page size to the offset so we load the next page next time
            const pageSize = queryVariables.limit || artifact.refetch.pageSize;
            currentOffset += pageSize;
            // we're not loading any more
            loading.set(false);
        },
        async refetch(params) {
            const { variables } = params ?? {};
            // if the input is different than the query variables then we just do everything like normal
            if (variables && !(0, __1.deepEquals)(extraVariables(), variables)) {
                return refetch(params);
            }
            // we are updating the current set of items, count the number of items that currently exist
            // and ask for the full data set
            const count = countPage(artifact.refetch.path, value) || artifact.refetch.pageSize;
            // build up the variables to pass to the query
            const queryVariables = {
                ...extraVariables(),
            };
            // if there are more records than the first page, we need fetch to load everything
            if (count > artifact.refetch.pageSize) {
                queryVariables.limit = count;
            }
            // set the loading state to true
            loading.set(true);
            // send the query
            const result = await refetch({
                ...params,
                variables: queryVariables,
            });
            // we're not loading any more
            loading.set(false);
            // we're not loading any more
            loading.set(false);
            return {
                data: result.data,
                variables: queryVariables,
                isFetching: false,
                partial: result.partial,
                errors: null,
                source: result.source,
            };
        },
    };
}
function missingPageSizeError(fnName) {
    return;
}
function extractPageInfo(data, path) {
    if (!data) {
        return {
            startCursor: null,
            endCursor: null,
            hasNextPage: false,
            hasPreviousPage: false,
        };
    }
    let localPath = [...path];
    // walk down the object until we get to the end
    let current = data;
    while (localPath.length > 0) {
        if (!current) {
            break;
        }
        current = current[localPath.shift()];
    }
    return current?.pageInfo ?? (0, exports.nullPageInfo)();
}
exports.extractPageInfo = extractPageInfo;
function countPage(source, value) {
    let data = value;
    if (value === null || data === null) {
        return 0;
    }
    for (const field of source) {
        const obj = data[field];
        if (obj && !Array.isArray(obj)) {
            data = obj;
        }
        else if (!data) {
            throw new Error('Could not count page size');
        }
        if (Array.isArray(obj)) {
            return obj.length;
        }
    }
    return 0;
}
exports.countPage = countPage;
const nullPageInfo = () => ({
    startCursor: null,
    endCursor: null,
    hasNextPage: false,
    hasPreviousPage: false,
});
exports.nullPageInfo = nullPageInfo;
