"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mutationStore = void 0;
// externals
const store_1 = require("svelte/store");
// locals
const lib_1 = require("../lib");
const cache_1 = __importDefault(require("../cache"));
const scalars_1 = require("../lib/scalars");
function mutationStore({ config, artifact, }) {
    const { subscribe, set, update } = (0, store_1.writable)({
        data: null,
        errors: null,
        isFetching: false,
        isOptimisticResponse: false,
        variables: null,
    });
    const mutate = async ({ variables, context, metadata, ...mutationConfig }) => {
        let fetchContext = context || {
            session: () => null,
        };
        update((c) => {
            return { ...c, isFetching: true };
        });
        // treat a mutation like it has an optimistic layer regardless of
        // whether there actually _is_ one. This ensures that a query which fires
        // after this mutation has been sent will overwrite any return values from the mutation
        //
        // as far as I can tell, this is an arbitrary decision but it does give a
        // well-defined ordering to a subtle situation so that seems like a win
        //
        const layer = cache_1.default._internal_unstable.storage.createLayer(true);
        // if there is an optimistic response then we need to write the value immediately
        const optimisticResponse = mutationConfig?.optimisticResponse;
        // hold onto the list of subscribers that we updated because of the optimistic response
        // and make sure they are included in the final set of subscribers to notify
        let toNotify = [];
        if (optimisticResponse) {
            toNotify = cache_1.default.write({
                selection: artifact.selection,
                // make sure that any scalar values get processed into something we can cache
                data: (0, scalars_1.marshalSelection)({
                    config,
                    selection: artifact.selection,
                    data: optimisticResponse,
                }),
                variables,
                layer: layer.id,
            });
            const storeData = {
                data: optimisticResponse,
                errors: null,
                isFetching: true,
                isOptimisticResponse: true,
                variables,
            };
            // update the store value
            set(storeData);
        }
        const newVariables = (0, scalars_1.marshalInputs)({
            input: variables,
            artifact,
            config,
        });
        try {
            // trigger the mutation
            const { result } = await (0, lib_1.executeQuery)({
                config,
                artifact,
                variables: newVariables,
                session: fetchContext.session?.(),
                cached: false,
                metadata,
            });
            if (result.errors && result.errors.length > 0) {
                update((s) => ({
                    ...s,
                    errors: result.errors,
                    isFetching: false,
                    isOptimisticResponse: false,
                    data: result.data,
                    variables: (newVariables || {}),
                }));
                throw result.errors;
            }
            // clear the layer holding any mutation results
            layer.clear();
            // write the result of the mutation to the cache
            cache_1.default.write({
                selection: artifact.selection,
                data: result.data,
                variables: newVariables,
                // write to the mutation's layer
                layer: layer.id,
                // notify any subscribers that we updated with the optimistic response
                // in order to address situations where the optimistic update was wrong
                notifySubscribers: toNotify,
                // make sure that we notify subscribers for any values that we overwrite
                // in order to address any race conditions when comparing the previous value
                forceNotify: true,
            });
            // merge the layer back into the cache
            cache_1.default._internal_unstable.storage.resolveLayer(layer.id);
            // prepare store data
            const storeData = {
                data: (0, scalars_1.unmarshalSelection)(config, artifact.selection, result.data),
                errors: result.errors ?? null,
                isFetching: false,
                isOptimisticResponse: false,
                variables: newVariables,
            };
            // update the store value
            set(storeData);
            // return the value to the caller
            return storeData;
        }
        catch (error) {
            update((s) => ({
                ...s,
                errors: error,
                isFetching: false,
                isOptimisticResponse: false,
                data: null,
                variables: newVariables,
            }));
            // if the mutation failed, roll the layer back and delete it
            layer.clear();
            cache_1.default._internal_unstable.storage.resolveLayer(layer.id);
            // bubble the mutation error up to the caller
            throw error;
        }
    };
    return {
        name: artifact.name,
        subscribe,
        mutate,
    };
}
exports.mutationStore = mutationStore;
