"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pageInfoSelection = void 0;
// externals
const graphql = __importStar(require("graphql"));
const common_1 = require("../../common");
const types_1 = require("../../runtime/lib/types");
// locals
const types_2 = require("../types");
const utils_1 = require("../utils");
// paginate transform adds the necessary fields for a paginated field
async function paginate(config, documents) {
    // we're going to have to add documents to the list so collect them here and we'll add them when we're done
    const newDocs = [];
    // visit every document
    for (const doc of documents) {
        // remember if we ran into a paginate argument
        let paginated = false;
        // store the pagination state to coordinate what we define as args to the field and the argument definitions of
        // the fragment and operation. we'll fill in the enabled state and default values once we encounter @paginate
        const flags = {
            first: {
                enabled: false,
                type: 'Int',
            },
            after: {
                enabled: false,
                type: 'String',
            },
            last: {
                enabled: false,
                type: 'Int',
            },
            before: {
                enabled: false,
                type: 'String',
            },
            limit: {
                enabled: false,
                type: 'Int',
            },
            offset: {
                enabled: false,
                type: 'Int',
            },
        };
        let cursorType = 'String';
        // we need to know the path where the paginate directive shows up so we can distinguish updated
        // values from data that needs to be added to the list
        let paginationPath = [];
        // we need to add page info to the selection
        doc.document = graphql.visit(doc.document, {
            Field(node, _, __, ___, ancestors) {
                // if there's no paginate directive, ignore the field
                const paginateDirective = node.directives?.find((directive) => directive.name.value === config.paginateDirective);
                if (!paginateDirective || !node.selectionSet) {
                    return;
                }
                // remember we saw this directive
                paginated = true;
                // loop over the args of the field once so we can check their existence
                const fieldTypeFields = (0, common_1.parentTypeFromAncestors)(config.schema, doc.filename, ancestors).getFields()[node.name.value];
                const args = new Set(fieldTypeFields.args.map((arg) => arg.name));
                // also look to see if the user wants to do forward pagination
                const passedArgs = new Set(node.arguments?.map((arg) => arg.name.value));
                const specifiedForwards = passedArgs.has('first');
                const specifiedBackwards = passedArgs.has('last');
                cursorType =
                    fieldTypeFields.args?.find((arg) => ['before', 'after'].includes(arg.name))
                        ?.type?.name || 'String';
                flags.after.type = cursorType;
                flags.before.type = cursorType;
                // figure out what kind of pagination the field supports
                const forwardPagination = !specifiedBackwards && args.has('first') && args.has('after');
                const backwardsPagination = !specifiedForwards && args.has('last') && args.has('before');
                const offsetPagination = !forwardPagination &&
                    !backwardsPagination &&
                    args.has('offset') &&
                    args.has('limit');
                // update the flags based on what the tagged field supports
                flags.first.enabled = forwardPagination;
                flags.after.enabled = forwardPagination;
                flags.last.enabled = backwardsPagination;
                flags.before.enabled = backwardsPagination;
                flags.offset.enabled = offsetPagination;
                flags.limit.enabled = offsetPagination;
                paginationPath = ancestors
                    .filter((ancestor) => 
                // @ts-ignore
                !Array.isArray(ancestor) && ancestor.kind === graphql.Kind.FIELD)
                    .concat(node).map((field) => field.alias?.value || field.name.value);
                // if the field supports cursor based pagination we need to make sure we have the
                // page info field
                return {
                    ...node,
                    // any pagination arguments we run into will need to be replaced with variables
                    // since they will be hoisted into the arguments for the fragment or query
                    arguments: replaceArgumentsWithVariables(node.arguments, flags),
                    selectionSet: offsetPagination
                        ? // no need to add any fields to the selection if we're dealing with offset pagination
                            node.selectionSet
                        : // add the page info if we are dealing with cursor-based pagination
                            {
                                ...node.selectionSet,
                                selections: [...node.selectionSet.selections, ...exports.pageInfoSelection],
                            },
                };
            },
        });
        // if we saw the paginate directive we need to add arguments to the fragment or query that contain the
        // field that is marked for pagination
        if (paginated) {
            let fragmentName = '';
            let refetchQueryName = '';
            // check if we have to embed the fragment in Node
            let nodeQuery = false;
            // figure out the right refetch
            let refetchUpdate = types_2.RefetchUpdateMode.append;
            if (flags.last.enabled) {
                refetchUpdate = types_2.RefetchUpdateMode.prepend;
            }
            // remember if we found a fragment or operation
            let fragment = '';
            doc.document = graphql.visit(doc.document, {
                // if we are dealing with a query, we'll need to add the variables to the definition
                OperationDefinition(node) {
                    // make sure its a query
                    if (node.operation !== 'query') {
                        throw {
                            filepath: doc.filename,
                            message: `@${config.paginateDirective} can only show up in a query or fragment document`,
                        };
                    }
                    refetchQueryName = node.name?.value || '';
                    // build a map from existing variables to their value so we can compare with the ones we need to inject
                    const operationVariables = node.variableDefinitions?.reduce((vars, definition) => ({
                        ...vars,
                        [definition.variable.name.value]: definition,
                    }), {}) || {};
                    // figure out the variables we want on the query
                    let newVariables = Object.fromEntries(Object.entries(flags)
                        .filter(([, spec]) => spec.enabled)
                        .map(([fieldName, spec]) => [
                        fieldName,
                        staticVariableDefinition(fieldName, spec.type, spec.defaultValue),
                    ]));
                    // the full list of variables comes from both source
                    const variableNames = new Set(Object.keys(operationVariables).concat(Object.keys(newVariables)));
                    // we need to build a unique set of variable definitions
                    const finalVariables = [...variableNames].map((name) => operationVariables[name] || newVariables[name]);
                    return {
                        ...node,
                        variableDefinitions: finalVariables,
                    };
                },
                // if we are dealing with a fragment definition we'll need to add the arguments directive if it doesn't exist
                FragmentDefinition(node) {
                    fragment = node.typeCondition.name.value;
                    fragmentName = node.name.value;
                    refetchQueryName = config.paginationQueryName(fragmentName);
                    // a fragment has to be embedded in Node if its not on the query type
                    nodeQuery = node.typeCondition.name.value !== config.schema.getQueryType()?.name;
                    // look at the fragment definition for an arguments directive
                    const argDirective = node.directives?.find((directive) => directive.name.value === config.argumentsDirective);
                    // if there isn't an arguments directive, add it and we'll add arguments to it when
                    // we run into it again
                    if (!argDirective) {
                        return {
                            ...node,
                            directives: [
                                ...(node.directives || []),
                                {
                                    kind: 'Directive',
                                    name: {
                                        kind: 'Name',
                                        value: config.argumentsDirective,
                                    },
                                },
                            ],
                        };
                    }
                },
                Directive(node) {
                    // if we are not looking at the arguments directive, ignore it
                    if (node.name.value !== config.argumentsDirective) {
                        return;
                    }
                    // turn the set of enabled pagination args into arg definitions for the directive
                    let newArgs = [
                        ...Object.entries(flags)
                            .filter(([, spec]) => spec.enabled)
                            .map(([key, spec]) => argumentNode(key, [spec.type, spec.defaultValue])),
                    ];
                    // add non-null versions of the arguments we'll use to paginate
                    return {
                        ...node,
                        arguments: [...(node.arguments || []), ...newArgs],
                    };
                },
            });
            // now that we've mutated the document to be flexible for @paginate's needs
            // we need to add a document to perform the query if we are paginating on a
            // fragment
            // figure out the 'target' type of the refetch
            let targetType = config.schema.getQueryType()?.name || '';
            if (fragment) {
                const nodeInterface = config.schema.getType('Node');
                if (nodeInterface) {
                    const { objects, interfaces } = config.schema.getImplementations(nodeInterface);
                    if (objects.find((obj) => obj.name === fragment) ||
                        interfaces.find((int) => int.name === fragment)) {
                        targetType = 'Node';
                    }
                    else {
                        targetType = fragment;
                    }
                }
                else {
                    targetType = fragment;
                }
            }
            // add the paginate info to the collected document
            doc.refetch = {
                update: refetchUpdate,
                path: paginationPath,
                method: flags.first.enabled || flags.last.enabled ? 'cursor' : 'offset',
                pageSize: 0,
                embedded: nodeQuery,
                targetType,
                paginated: true,
                direction: flags.last.enabled ? 'backwards' : 'forward',
            };
            // add the correct default page size
            if (flags.first.enabled) {
                doc.refetch.pageSize = flags.first.defaultValue;
                doc.refetch.start = flags.after.defaultValue;
            }
            else if (flags.last.enabled) {
                doc.refetch.pageSize = flags.last.defaultValue;
                doc.refetch.start = flags.before.defaultValue;
            }
            else if (flags.limit.enabled) {
                doc.refetch.pageSize = flags.limit.defaultValue;
                doc.refetch.start = flags.offset.defaultValue;
            }
            // if we're not paginating a fragment, there's nothing more to do. we mutated
            // the query's definition to contain the arguments we need to get more data
            // and we can just use it for refetches
            if (!fragment) {
                continue;
            }
            // grab the enabled fields to create the list of arguments for the directive
            const paginationArgs = Object.entries(flags)
                .filter(([_, { enabled }]) => enabled)
                .map(([key, value]) => ({ name: key, ...value }));
            const fragmentSpreadSelection = [
                {
                    kind: 'FragmentSpread',
                    name: {
                        kind: 'Name',
                        value: fragmentName,
                    },
                    directives: [
                        {
                            kind: 'Directive',
                            name: {
                                kind: 'Name',
                                value: config.withDirective,
                            },
                            ['arguments']: paginationArgs.map(({ name }) => variableAsArgument(name)),
                        },
                    ],
                },
            ];
            // we are going to add arguments for every key the type is configured with
            const keys = config
                .keyFieldsForType(!nodeQuery ? config.schema.getQueryType()?.name || '' : fragment)
                .flatMap((key) => {
                // if we are looking at the query, don't add anything
                if (fragment === config.schema.getQueryType()?.name) {
                    return [];
                }
                // look up the type for each key
                const fragmentType = config.schema.getType(fragment);
                const { type, wrappers } = (0, utils_1.unwrapType)(config, fragmentType.getFields()[key].type);
                return [
                    {
                        name: key,
                        type: (0, utils_1.wrapType)({ type, wrappers }),
                    },
                ];
            });
            const typeConfig = config.typeConfig?.[fragment];
            const queryDoc = {
                kind: 'Document',
                definitions: [
                    {
                        kind: 'OperationDefinition',
                        name: {
                            kind: 'Name',
                            value: refetchQueryName,
                        },
                        operation: 'query',
                        variableDefinitions: paginationArgs
                            .map((arg) => ({
                            kind: 'VariableDefinition',
                            type: {
                                kind: 'NamedType',
                                name: {
                                    kind: 'Name',
                                    value: arg.type,
                                },
                            },
                            variable: {
                                kind: 'Variable',
                                name: {
                                    kind: 'Name',
                                    value: arg.name,
                                },
                            },
                            defaultValue: !flags[arg.name].defaultValue
                                ? undefined
                                : {
                                    kind: (arg.type + 'Value'),
                                    value: flags[arg.name].defaultValue,
                                },
                        }))
                            .concat(!nodeQuery
                            ? []
                            : keys.map((key) => ({
                                kind: 'VariableDefinition',
                                type: key.type,
                                variable: {
                                    kind: 'Variable',
                                    name: {
                                        kind: 'Name',
                                        value: key.name,
                                    },
                                },
                            }))),
                        selectionSet: {
                            kind: 'SelectionSet',
                            selections: !nodeQuery
                                ? fragmentSpreadSelection
                                : [
                                    {
                                        kind: 'Field',
                                        name: {
                                            kind: 'Name',
                                            value: typeConfig?.resolve?.queryField || 'node',
                                        },
                                        ['arguments']: keys.map((key) => ({
                                            kind: 'Argument',
                                            name: {
                                                kind: 'Name',
                                                value: key.name,
                                            },
                                            value: {
                                                kind: 'Variable',
                                                name: {
                                                    kind: 'Name',
                                                    value: key.name,
                                                },
                                            },
                                        })),
                                        selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                                // make sure we look up the type of the result
                                                {
                                                    kind: 'Field',
                                                    name: { kind: 'Name', value: '__typename' },
                                                },
                                                // make sure every key field is present
                                                ...(typeConfig?.keys || ['id']).map((key) => ({
                                                    kind: 'Field',
                                                    name: { kind: 'Name', value: key },
                                                })),
                                                ...fragmentSpreadSelection,
                                            ],
                                        },
                                    },
                                ],
                        },
                    },
                ],
            };
            // add a document to the list
            newDocs.push({
                kind: types_1.ArtifactKind.Query,
                filename: doc.filename,
                name: refetchQueryName,
                document: queryDoc,
                originalDocument: queryDoc,
                generateArtifact: true,
                generateStore: false,
                refetch: doc.refetch,
                originalString: '',
            });
        }
    }
    // add every new doc we generated to the list
    documents.push(...newDocs);
}
exports.default = paginate;
function replaceArgumentsWithVariables(args, flags) {
    const seenArgs = {};
    const newArgs = (args || []).map((arg) => {
        // the specification for this variable
        const spec = flags[arg.name.value];
        // if the arg is not something we care about or is disabled we need to leave it alone
        if (!spec || !spec.enabled) {
            return arg;
        }
        // if the argument isn't being passed a variable, we will need to set a default value
        if (arg.value.kind !== 'Variable') {
            const oldValue = arg.value.value;
            // transform the value if we have to and save the default value
            flags[arg.name.value].defaultValue = spec.type === 'Int' ? parseInt(oldValue) : oldValue;
        }
        seenArgs[arg.name.value] = true;
        // turn the field into a variable
        return variableAsArgument(arg.name.value);
    });
    // any fields that are enabled but don't have values need to have variable references add
    for (const name of Object.keys(flags)) {
        // the specification for this variable
        const spec = flags[name];
        // if we have a value or its disabled, ignore it
        if (flags[name].defaultValue || !spec.enabled || seenArgs[name]) {
            continue;
        }
        // if we are looking at forward pagination args when backwards is enabled ignore it
        if (['first', 'after'].includes(name) && flags['before'].enabled) {
            continue;
        }
        // same but opposite for backwards pagination
        if (['last', 'before'].includes(name) && flags['first'].enabled) {
            continue;
        }
        // we need to add a variable referencing the argument
        newArgs.push(variableAsArgument(name));
    }
    return newArgs;
}
function variableAsArgument(name) {
    return {
        kind: 'Argument',
        name: {
            kind: 'Name',
            value: name,
        },
        value: {
            kind: 'Variable',
            name: {
                kind: 'Name',
                value: name,
            },
        },
    };
}
function staticVariableDefinition(name, type, defaultValue) {
    return {
        kind: 'VariableDefinition',
        type: {
            kind: 'NamedType',
            name: {
                kind: 'Name',
                value: type,
            },
        },
        variable: {
            kind: 'Variable',
            name: {
                kind: 'Name',
                value: name,
            },
        },
        defaultValue: !defaultValue
            ? undefined
            : {
                kind: (type + 'Value'),
                value: defaultValue,
            },
    };
}
function argumentNode(name, value) {
    return {
        kind: 'Argument',
        name: {
            kind: 'Name',
            value: name,
        },
        value: objectNode(value),
    };
}
function objectNode([type, defaultValue]) {
    const node = {
        kind: 'ObjectValue',
        fields: [
            {
                kind: 'ObjectField',
                name: {
                    kind: 'Name',
                    value: 'type',
                },
                value: {
                    kind: 'StringValue',
                    value: type,
                },
            },
        ],
    };
    // if there's a default value, add it
    if (defaultValue) {
        node.fields.push({
            kind: 'ObjectField',
            name: { kind: 'Name', value: 'default' },
            value: {
                kind: typeof defaultValue === 'number' ? 'IntValue' : 'StringValue',
                value: defaultValue.toString(),
            },
        });
    }
    return node;
}
exports.pageInfoSelection = [
    {
        kind: 'Field',
        name: {
            kind: 'Name',
            value: 'edges',
        },
        selectionSet: {
            kind: 'SelectionSet',
            selections: [
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'cursor',
                    },
                },
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'node',
                    },
                    selectionSet: {
                        kind: 'SelectionSet',
                        selections: [
                            {
                                kind: 'Field',
                                name: {
                                    kind: 'Name',
                                    value: '__typename',
                                },
                            },
                        ],
                    },
                },
            ],
        },
    },
    {
        kind: 'Field',
        name: {
            kind: 'Name',
            value: 'pageInfo',
        },
        selectionSet: {
            kind: 'SelectionSet',
            selections: [
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'hasPreviousPage',
                    },
                },
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'hasNextPage',
                    },
                },
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'startCursor',
                    },
                },
                {
                    kind: 'Field',
                    name: {
                        kind: 'Name',
                        value: 'endCursor',
                    },
                },
            ],
        },
    },
];
