"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// externals
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const url_1 = require("url");
const utils_1 = require("../../utils");
const adapter_1 = __importDefault(require("./adapter"));
// @ts-ignore
const currentDir = global.__dirname || path_1.default.dirname((0, url_1.fileURLToPath)(import.meta.url));
async function runtimeGenerator(config, docs) {
    // when running in the real world, scripts are nested in a sub directory of build, in tests they aren't nested
    // under /src so we need to figure out how far up to go to find the appropriately compiled runtime
    const relative = process.env.TEST ? '../../../../' : '../';
    // we want to copy the typescript source code for the templates and then compile the files according
    // to the requirements of the platform
    const source = path_1.default.resolve(currentDir, relative, 'build', config.module === 'esm' ? 'runtime-esm' : 'runtime-cjs');
    // copy the compiled source code to the target directory
    await recursiveCopy(config, source, config.runtimeDirectory);
    // generate the adapter to normalize interactions with the framework
    await (0, adapter_1.default)(config);
}
exports.default = runtimeGenerator;
async function recursiveCopy(config, source, target, notRoot) {
    // if the folder containing the target doesn't exist, then we need to create it
    let parentDir = path_1.default.join(target, path_1.default.basename(source));
    // if we are at the root, then go up one
    if (!notRoot) {
        parentDir = path_1.default.join(parentDir, '..');
    }
    try {
        await promises_1.default.access(parentDir);
        // the parent directory does not exist
    }
    catch (e) {
        await promises_1.default.mkdir(parentDir);
    }
    // check if we are copying a directory
    if ((await promises_1.default.stat(source)).isDirectory()) {
        // look in the contents of the source directory
        await Promise.all((await promises_1.default.readdir(source)).map(async (child) => {
            // figure out the full path of the source
            const childPath = path_1.default.join(source, child);
            // TODO: find a better way of handling this. The runtime needs to be able to import the config file
            //       to support features like custom scalars. In order to pull this off, this generator
            //       copies the compiled runtime and then manually adds an import to the config file.
            //       The runtime index file already exports the config file but for some reason vite
            //       can't find the exported value when it comes from inside. It has no problem
            //       finding the config reference exported from $houdini from the preprocessor ðŸ¤·
            const isCacheIndex = source.substring(source.lastIndexOf(path_1.default.sep) + 1) === 'cache' &&
                child === 'index.js';
            const cacheIndexPath = path_1.default.join(config.runtimeDirectory, 'cache', 'index.js');
            // if the child is a directory
            if ((await promises_1.default.lstat(childPath)).isDirectory()) {
                // keep walking down
                await recursiveCopy(config, childPath, parentDir, true);
            }
            // the child is a file, copy it to the parent directory
            else {
                const targetPath = path_1.default.join(parentDir, child);
                let contents = await promises_1.default.readFile(childPath, 'utf-8');
                // if we are writing to the cache index file, modify the contents
                if (isCacheIndex) {
                    const relativePath = path_1.default
                        .relative(cacheIndexPath, config.filepath)
                        .slice('../'.length)
                        .split(path_1.default.sep)
                        .join('/');
                    contents =
                        (config.module === 'esm'
                            ? `import config from "${relativePath}"\n`
                            : `var config = require('${relativePath}');`) +
                            contents.replace('"use strict";', '');
                }
                await (0, utils_1.writeFile)(targetPath, contents);
            }
        }));
    }
}
