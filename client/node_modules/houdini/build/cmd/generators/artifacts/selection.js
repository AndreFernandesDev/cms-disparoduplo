"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// externals
const graphql = __importStar(require("graphql"));
const recast = __importStar(require("recast"));
// locals
const common_1 = require("../../../common");
const fieldKey_1 = __importDefault(require("./fieldKey"));
const utils_1 = require("./utils");
const list_1 = require("../../transforms/list");
const AST = recast.types.builders;
function selection({ config, filepath, rootType, selections, operations, path = [], includeFragments, document, markEdges, }) {
    // we need to build up an object that contains every field in the selection
    let object = {};
    for (const field of selections) {
        // ignore fragment spreads
        if (field.kind === 'FragmentSpread' && includeFragments) {
            // look up the fragment definition
            const fragmentDefinition = document.document.definitions.find((defn) => defn.kind === 'FragmentDefinition' && defn.name.value === field.name.value);
            if (!fragmentDefinition) {
                throw {
                    filepath,
                    message: 'selection: could not find definition for fragment ' + field.name.value,
                };
            }
            // merge the fragments selection into ours
            object = (0, utils_1.deepMerge)(filepath, object, selection({
                config,
                filepath,
                rootType: fragmentDefinition.typeCondition.name.value,
                operations,
                selections: fragmentDefinition.selectionSet.selections,
                path,
                includeFragments,
                document,
            }));
        }
        // inline fragments should be merged with the parent
        else if (field.kind === 'InlineFragment') {
            object = (0, utils_1.deepMerge)(filepath, object, selection({
                config,
                filepath,
                rootType: field.typeCondition?.name.value || rootType,
                operations,
                selections: field.selectionSet.selections,
                path,
                includeFragments,
                document,
            }));
        }
        // fields need their own entry
        else if (field.kind === 'Field') {
            // look up the field
            const type = config.schema.getType(rootType);
            if (!type) {
                throw { filepath, message: 'Could not find type' };
            }
            const attributeName = field.alias?.value || field.name.value;
            // if we are looking at __typename, its a string (not defined in the schema)
            let fieldType;
            let nullable = false;
            if (field.name.value === '__typename') {
                fieldType = config.schema.getType('String');
            }
            else {
                let typeRef = type.getFields()[field.name.value].type;
                fieldType = (0, common_1.getRootType)(typeRef);
                nullable = !graphql.isNonNullType(typeRef);
            }
            const typeName = fieldType.toString();
            // make sure we include the attribute in the path
            const pathSoFar = path.concat(attributeName);
            // the object holding data for this field
            const fieldObj = {
                type: typeName,
                keyRaw: (0, fieldKey_1.default)(config, field),
            };
            if (nullable) {
                fieldObj.nullable = true;
            }
            // is there an operation for this field
            const operationKey = pathSoFar.join(',');
            if (operations[operationKey]) {
                fieldObj.operations = operations[operationKey];
            }
            // get the name of the list directive tagging this field
            const listDirective = field.directives?.find((directive) => [config.listDirective, config.paginateDirective].includes(directive.name.value));
            const nameArg = listDirective?.arguments?.find((arg) => arg.name.value === 'name');
            if (nameArg && nameArg.value.kind === 'StringValue') {
                const { connection, type: connectionType } = (0, list_1.connectionSelection)(config, type.getFields()[field.name.value], fieldType, field.selectionSet);
                fieldObj.list = {
                    name: nameArg.value.value,
                    connection,
                    type: connectionType.name,
                };
            }
            // if the field is marked for pagination we want to leave something behind
            // so that cache.write can perform the necessary inserts when appropriate
            const paginated = field.directives?.find((directive) => directive.name.value === config.paginateDirective);
            // if the field is marked for offset pagination we need to mark this field
            if (paginated && document.refetch && document.refetch.method === 'offset') {
                fieldObj.update = document.refetch.update;
            }
            // if we are looking at the edges field and we're supposed to mark it for pagination
            if (attributeName === 'edges' && markEdges && document.refetch) {
                // otherwise mark this field
                fieldObj.update = document.refetch.update;
                // make sure we don't mark the children
                markEdges = '';
            }
            // only add the field object if there are properties in it
            if (field.selectionSet) {
                // if this field was marked for cursor based pagination we need to mark
                // the edges field that falls underneath it
                const edgesMark = paginated && document.refetch?.method === 'cursor'
                    ? document.refetch.update
                    : markEdges;
                fieldObj.fields = selection({
                    config,
                    filepath,
                    rootType: typeName,
                    selections: field.selectionSet.selections,
                    operations,
                    path: pathSoFar,
                    includeFragments,
                    document,
                    markEdges: edgesMark,
                });
            }
            // any arguments on the list field can act as a filter
            if (field.arguments?.length && fieldObj.list) {
                fieldObj.filters = (field.arguments || []).reduce((filters, arg) => ({
                    ...filters,
                    [arg.name.value]: (0, utils_1.convertValue)(arg.value),
                }), {});
            }
            // if we are looking at an interface
            if (graphql.isInterfaceType(fieldType) || graphql.isUnionType(fieldType)) {
                fieldObj.abstract = true;
            }
            // add the field data we computed
            object[attributeName] = (0, utils_1.deepMerge)(filepath, fieldObj, object[attributeName] || {});
        }
    }
    return object;
}
exports.default = selection;
