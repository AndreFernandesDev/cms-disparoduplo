"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// externals
const graphql = __importStar(require("graphql"));
const recast = __importStar(require("recast"));
const promises_1 = __importDefault(require("fs/promises"));
// locals
const common_1 = require("../../../common");
const utils_1 = require("../../utils");
const selection_1 = __importDefault(require("./selection"));
const operations_1 = require("./operations");
const indexFile_1 = __importDefault(require("./indexFile"));
const inputs_1 = require("./inputs");
const utils_2 = require("./utils");
const types_1 = require("../../../runtime/lib/types");
const AST = recast.types.builders;
// the artifact generator creates files in the runtime directory for each
// document containing meta data that the preprocessor might use
function artifactGenerator(stats) {
    return async function (config, docs) {
        // put together the type information for the filter for every list
        const filterTypes = {};
        for (const doc of docs) {
            graphql.visit(doc.document, {
                // look for any field marked with alist
                Directive(node, _, __, ___, ancestors) {
                    // we only care about lists
                    if (node.name.value !== config.listDirective) {
                        return;
                    }
                    // get the name of thelist
                    const nameArg = node.arguments?.find((arg) => arg.name.value === config.listNameArg);
                    if (!nameArg || nameArg.value.kind !== 'StringValue') {
                        throw {
                            filepath: doc.filename,
                            message: 'could not find name arg in list directive',
                        };
                    }
                    const listName = nameArg.value.value;
                    // look up the actual field in the ancestor list so we can get type info
                    let field = ancestors[ancestors.length - 1];
                    let i = 1;
                    while (Array.isArray(field)) {
                        i++;
                        field = ancestors[ancestors.length - i];
                    }
                    if (field.kind !== 'Field') {
                        return;
                    }
                    // look up the parent's type so we can ask about the field marked as alist
                    const parentType = (0, common_1.parentTypeFromAncestors)(config.schema, doc.filename, [
                        ...ancestors.slice(0, -1),
                    ]);
                    const parentField = parentType.getFields()[field.name.value];
                    if (!parentField) {
                        throw {
                            filepath: doc.filename,
                            message: 'Could not find field information when computing filters',
                        };
                    }
                    const fieldType = (0, common_1.getRootType)(parentField.type).toString();
                    // look at every arg on the list to figure out the valid filters
                    filterTypes[listName] = parentField.args.reduce((prev, arg) => {
                        return {
                            ...prev,
                            [arg.name]: (0, common_1.getRootType)(arg.type).toString(),
                        };
                    }, {});
                    // the delete directive is an interesting one since there isn't a specific
                    // list. we need to use something that points to deleting an instance of
                    // the type as a key
                    filterTypes[`${fieldType}_delete`] = {
                        ...filterTypes[`${fieldType}_delete`],
                        // every field with the list type adds to the delete filters
                        ...filterTypes[listName],
                    };
                },
            });
        }
        // we have everything we need to generate the artifacts
        await Promise.all([
            // generate the index file
            (0, indexFile_1.default)(config, docs),
        ].concat(
        // and an artifact for every document
        docs.map(async (doc) => {
            // pull out the info we need from the collected doc
            const { document, name, generateArtifact } = doc;
            // if the document is generated, don't write it to disk - it's use is to provide definitions
            // for the other transforms
            if (!generateArtifact) {
                return;
            }
            // before we can print the document, we need to strip:
            // 1. all references to internal directives
            // 2. all variables only used by internal directives
            const usedVariableNames = new Set();
            let documentWithoutInternalDirectives = graphql.visit(document, {
                Directive(node) {
                    // if the directive is one of the internal ones, remove it
                    if (config.isInternalDirective(node)) {
                        return null;
                    }
                },
                Variable(node, _key, parent) {
                    const variableIsBeingDefined = parent &&
                        !(parent instanceof Array) &&
                        parent.kind === 'VariableDefinition';
                    if (!variableIsBeingDefined) {
                        usedVariableNames.add(node.name.value);
                    }
                },
            });
            let documentWithoutExtraVariables = graphql.visit(documentWithoutInternalDirectives, {
                VariableDefinition(variableDefinitionNode) {
                    const name = variableDefinitionNode.variable.name.value;
                    if (!usedVariableNames.has(name)) {
                        return null;
                    }
                },
            });
            let rawString = graphql.print(documentWithoutExtraVariables);
            // figure out the document kind
            let docKind = doc.kind;
            // look for the operation
            const operations = document.definitions.filter(({ kind }) => kind === graphql.Kind.OPERATION_DEFINITION);
            // there are no operations, so its a fragment
            const fragments = document.definitions.filter(({ kind }) => kind === graphql.Kind.FRAGMENT_DEFINITION);
            let rootType = '';
            let selectionSet;
            // if we are generating the artifact for an operation
            if (docKind !== types_1.ArtifactKind.Fragment) {
                // find the operation
                const operation = operations[0];
                if (operation.operation === 'query') {
                    rootType = config.schema.getQueryType()?.name;
                }
                else if (operation.operation === 'mutation') {
                    rootType = config.schema.getMutationType()?.name;
                }
                else if (operation.operation === 'subscription') {
                    rootType = config.schema.getSubscriptionType()?.name;
                }
                if (!rootType) {
                    throw {
                        filepath: doc.filename,
                        message: 'could not find root type for operation: ' +
                            operation.operation +
                            '. Maybe you need to re-run the introspection query?',
                    };
                }
                // use this selection set
                selectionSet = operation.selectionSet;
            }
            // we are looking at a fragment so use its selection set and type for the subscribe index
            else {
                // there are a lot of fragments added to a document. The fragment we care about
                // is the one with the matching name
                const matchingFragment = fragments.find((fragment) => fragment.name.value === name);
                if (!matchingFragment) {
                    throw {
                        filepath: doc.filename,
                        message: `Fragment "${name}" doesn't exist in its own document?!`,
                    };
                }
                rootType = matchingFragment.typeCondition.name.value;
                selectionSet = matchingFragment.selectionSet;
            }
            // if there are inputs to the operation
            const inputs = operations[0]?.variableDefinitions;
            // generate a hash of the document that we can use to detect changes
            // start building up the artifact
            const artifact = {
                name,
                kind: docKind,
                hash: (0, common_1.hashDocument)(rawString),
                refetch: doc.refetch,
                raw: rawString,
                rootType,
                selection: (0, selection_1.default)({
                    config,
                    filepath: doc.filename,
                    rootType,
                    selections: selectionSet.selections,
                    operations: (0, operations_1.operationsByPath)(config, doc.filename, operations[0], filterTypes),
                    // do not include used fragments if we are rendering the selection
                    // for a fragment document
                    includeFragments: docKind !== 'HoudiniFragment',
                    document: doc,
                }),
            };
            // if the document has inputs describe their types in the artifact so we can
            // marshal and unmarshal scalars
            if (inputs && inputs.length > 0) {
                artifact.input = (0, inputs_1.inputObject)(config, inputs);
            }
            // add the cache policy to query documents
            if (docKind === 'HoudiniQuery') {
                const cacheDirective = operations[0].directives?.find((directive) => directive.name.value === config.cacheDirective);
                if (cacheDirective) {
                    // look for arguments
                    const args = cacheDirective.arguments?.reduce((acc, arg) => ({
                        ...acc,
                        [arg.name.value]: arg,
                    }), {}) || {};
                    const policy = args[config.cachePolicyArg];
                    if (policy && policy.value.kind === 'EnumValue') {
                        artifact.policy = policy.value.value;
                    }
                    else {
                        artifact.policy = config.defaultCachePolicy;
                    }
                    // if the user opted-in for partial data
                    const partial = args[config.cachePartialArg];
                    if (partial && partial.value.kind === 'BooleanValue') {
                        artifact.partial = partial.value.value;
                    }
                    else {
                        artifact.partial = config.defaultPartial;
                    }
                }
                else {
                    artifact.policy = config.defaultCachePolicy;
                    artifact.partial = config.defaultPartial;
                }
            }
            // the artifact should be the default export of the file
            const file = AST.program([
                (0, utils_1.moduleExport)(config, 'default', (0, utils_2.serializeValue)(artifact)),
                AST.expressionStatement(AST.stringLiteral(`HoudiniHash=${(0, common_1.hashDocument)(doc.originalString)}`)),
            ]);
            const artifactPath = config.artifactPath(document);
            // don't count the document unless it's user-facing (ie, generates a store)
            const countDocument = doc.generateStore;
            // check if the file exists (indicating a new document)
            let existingArtifact = '';
            try {
                existingArtifact = await promises_1.default.readFile(artifactPath, 'utf-8');
            }
            catch (e) {
                if (countDocument) {
                    stats.new.push(artifact.name);
                }
            }
            // write the result to the artifact path we're configured to write to
            await (0, utils_1.writeFile)(artifactPath, recast.print(file).code);
            if (!countDocument) {
                return;
            }
            // check if the artifact exists
            const match = existingArtifact.match(/"HoudiniHash=(\w+)"/);
            if (match && match[1] !== (0, common_1.hashDocument)(doc.originalString)) {
                stats.changed.push(artifact.name);
            }
            // regardless of wether it was changed or not, we need to track the total list of artifacts
            stats.total.push(artifact.name);
        })));
    };
}
exports.default = artifactGenerator;
