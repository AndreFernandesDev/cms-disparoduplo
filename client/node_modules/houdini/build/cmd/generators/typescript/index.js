"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const recast = __importStar(require("recast"));
const helper_1 = require("@kitql/helper");
const utils_1 = require("../../utils");
const addReferencedInputTypes_1 = require("./addReferencedInputTypes");
const inlineType_1 = require("./inlineType");
const typeReference_1 = require("./typeReference");
const types_1 = require("./types");
const AST = recast.types.builders;
// typescriptGenerator generates typescript definitions for the artifacts
async function typescriptGenerator(config, docs) {
    // build up a list of paths we have types in (to export from index.d.ts)
    const typePaths = [];
    // we need every fragment definition
    const fragmentDefinitions = {};
    for (const document of docs) {
        // look at the parsed document for a fragment definition
        const fragmentDefn = document.originalDocument.definitions.find(({ kind }) => kind === 'FragmentDefinition');
        if (!fragmentDefn) {
            continue;
        }
        fragmentDefinitions[fragmentDefn.name.value] = fragmentDefn;
    }
    const missingScalars = new Set();
    // every document needs a generated type
    await Promise.all(
    // the generated types depend solely on user-provided information
    // so we need to use the original document that we haven't mutated
    // as part of the compiler
    docs.map(async ({ originalDocument, name, filename, generateArtifact }) => {
        if (!generateArtifact) {
            return;
        }
        // the place to put the artifact's type definition
        const typeDefPath = config.artifactTypePath(originalDocument);
        // build up the program
        const program = AST.program([]);
        // if we have to define any types along the way, make sure we only do it once
        const visitedTypes = new Set();
        // if there's an operation definition
        let definition = originalDocument.definitions.find((def) => (def.kind === 'OperationDefinition' || def.kind === 'FragmentDefinition') &&
            def.name?.value === name);
        const selections = (0, utils_1.flattenSelections)({
            config,
            filepath: filename,
            selections: definition.selectionSet.selections,
            // only globally include internal fragment values if masking is disabled
            includeFragments: config.disableMasking,
            fragmentDefinitions,
        });
        if (definition?.kind === 'OperationDefinition') {
            // treat it as an operation document
            await generateOperationTypeDefs(config, filename, program.body, definition, selections, visitedTypes, missingScalars);
        }
        else {
            // treat it as a fragment document
            await generateFragmentTypeDefs(config, filename, program.body, selections, originalDocument.definitions, visitedTypes, missingScalars);
        }
        // write the file contents
        await (0, utils_1.writeFile)(typeDefPath, recast.print(program).code);
        typePaths.push(typeDefPath);
    }));
    // now that we have every type generated, create an index file in the runtime root that exports the types
    const typeIndex = AST.program(typePaths
        .map((typePath) => {
        return AST.exportAllDeclaration(AST.literal('./' +
            path_1.default
                .relative(path_1.default.resolve(config.typeIndexPath, '..'), typePath)
                // remove the .d.ts from the end of the path
                .replace(/\.[^/.]+\.[^/.]+$/, '')), null);
    })
        .concat([
        AST.exportAllDeclaration(AST.literal('./runtime'), null),
        AST.exportAllDeclaration(AST.literal('./stores'), null),
        AST.exportAllDeclaration(AST.literal('./graphql'), null),
    ]));
    // write the contents
    await (0, utils_1.writeFile)(config.typeIndexPath, recast.print(typeIndex).code);
    // if we were missing scalars, we need to warn the user and tell them
    if (missingScalars.size > 0) {
        console.warn(`⚠️  Missing definitions for the following scalars: ${[...missingScalars].join(', ')}
Generated types will contain an any type in place of these values. To fix this, provide an equivalent
type in your config file:

{
  scalars: {
    ${(0, helper_1.logCyan)(`/* in your case, something like */`)}
${[...missingScalars]
            .map((c) => `    ${c}: {                  ${(0, helper_1.logGreen)(`// <- The GraphQL Scalar`)}
      type: "${(0, helper_1.logCyan)(`YourType_${c}`)}"  ${(0, helper_1.logGreen)(`// <-  The TypeScript type`)}
    }`)
            .join(`,
`)}
  }
}

For more information, please visit this link: https://www.houdinigraphql.com/api/config#custom-scalars`);
    }
}
exports.default = typescriptGenerator;
async function generateOperationTypeDefs(config, filepath, body, definition, selections, visitedTypes, missingScalars) {
    let parentType = null;
    if (definition.operation === 'query') {
        parentType = config.schema.getQueryType();
    }
    else if (definition.operation === 'mutation') {
        parentType = config.schema.getMutationType();
    }
    else if (definition.operation === 'subscription') {
        parentType = config.schema.getSubscriptionType();
    }
    if (!parentType) {
        throw { filepath, message: 'Could not find root type for document' };
    }
    // the name of the types we will define
    const inputTypeName = `${definition.name.value}$input`;
    const shapeTypeName = `${definition.name.value}$result`;
    const afterLoadTypeName = `${definition.name.value}$afterLoad`;
    // dry
    const hasInputs = definition.variableDefinitions && definition.variableDefinitions.length > 0;
    // add our types to the body
    body.push(
    // add the root type named after the document that links the input and result types
    AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(definition.name.value), AST.tsTypeLiteral([
        (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral('input'), AST.tsTypeAnnotation(hasInputs
            ? AST.tsTypeReference(AST.identifier(inputTypeName))
            : AST.tsNullKeyword()))),
        (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral('result'), AST.tsTypeAnnotation(definition.operation === 'mutation'
            ? AST.tsTypeReference(AST.identifier(shapeTypeName))
            : AST.tsUnionType([
                AST.tsTypeReference(AST.identifier(shapeTypeName)),
                AST.tsUndefinedKeyword(),
            ])))),
    ]))), 
    // export the type that describes the result
    AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(shapeTypeName), (0, inlineType_1.inlineType)({
        config,
        filepath,
        rootType: parentType,
        selections,
        root: true,
        allowReadonly: true,
        visitedTypes,
        body,
        missingScalars,
    }))));
    // generate type for the afterload function
    const properties = [
        (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral('data'), AST.tsTypeAnnotation(AST.tsTypeLiteral([
            (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral(definition.name.value), AST.tsTypeAnnotation(AST.tsTypeReference(AST.identifier(shapeTypeName))))),
        ])))),
    ];
    if (hasInputs) {
        properties.splice(0, 0, (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral('input'), AST.tsTypeAnnotation(AST.tsTypeLiteral([
            (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral(definition.name.value), AST.tsTypeAnnotation(AST.tsTypeReference(AST.identifier(inputTypeName))))),
        ])))));
    }
    if (definition.operation === 'query') {
        body.push(AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(afterLoadTypeName), AST.tsTypeLiteral(properties))));
    }
    // if there are variables in this query
    if (hasInputs && definition.variableDefinitions && definition.variableDefinitions.length > 0) {
        for (const variableDefinition of definition.variableDefinitions) {
            (0, addReferencedInputTypes_1.addReferencedInputTypes)(config, filepath, body, visitedTypes, missingScalars, variableDefinition.type);
        }
        // merge all of the variables into a single object
        body.push(AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(inputTypeName), AST.tsTypeLiteral((definition.variableDefinitions || []).map((definition) => {
            // add a property describing the variable to the root object
            return AST.tsPropertySignature(AST.identifier(definition.variable.name.value), AST.tsTypeAnnotation((0, typeReference_1.tsTypeReference)(config, missingScalars, definition)), definition.type.kind !== 'NonNullType');
        })))));
    }
}
async function generateFragmentTypeDefs(config, filepath, body, selections, definitions, visitedTypes, missingScalars) {
    // every definition will contribute the same thing to the typedefs
    for (const definition of definitions) {
        // if its not a fragment definition
        if (definition.kind !== 'FragmentDefinition') {
            // we don't know what to do
            continue;
        }
        // the name of the prop type
        const propTypeName = definition.name.value;
        // the name of the shape type
        const shapeTypeName = `${definition.name.value}$data`;
        // look up the root type of the document
        const type = config.schema.getType(definition.typeCondition.name.value);
        if (!type) {
            throw new Error('Should not get here');
        }
        body.push(
        // we need to add a type that will act as the entry point for the fragment
        // and be assigned to the prop that holds the reference passed from
        // the fragment's parent
        AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(propTypeName), AST.tsTypeLiteral([
            (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral('shape'), AST.tsTypeAnnotation(AST.tsTypeReference(AST.identifier(shapeTypeName))), true)),
            (0, types_1.readonlyProperty)(AST.tsPropertySignature(AST.stringLiteral(inlineType_1.fragmentKey), AST.tsTypeAnnotation(AST.tsTypeLiteral([
                AST.tsPropertySignature(AST.stringLiteral(propTypeName), AST.tsTypeAnnotation(AST.tsLiteralType(AST.booleanLiteral(true)))),
            ])))),
        ]))), 
        // export the type that describes the fragments response data
        AST.exportNamedDeclaration(AST.tsTypeAliasDeclaration(AST.identifier(shapeTypeName), (0, inlineType_1.inlineType)({
            config,
            filepath,
            rootType: type,
            selections,
            root: true,
            allowReadonly: true,
            body,
            visitedTypes,
            missingScalars,
        }))));
    }
}
