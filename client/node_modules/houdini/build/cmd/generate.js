"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPipeline = void 0;
// externals
const glob_1 = __importDefault(require("glob"));
const svelte = __importStar(require("svelte/compiler"));
const promises_1 = __importDefault(require("fs/promises"));
const graphql = __importStar(require("graphql"));
const util_1 = require("util");
// locals
const common_1 = require("../common");
const types_1 = require("./types");
const transforms = __importStar(require("./transforms"));
const generators = __importStar(require("./generators"));
const validators = __importStar(require("./validators"));
// the main entry point of the compile script
async function compile(config) {
    // grab the graphql documents
    const documents = await collectDocuments(config);
    // push the documents through the pipeline
    await runPipeline(config, documents);
}
exports.default = compile;
// the compiler's job can be broken down into a few different tasks after the documents have been collected:
// - validate their structure
// - perform a series of transformations
// - write the corresponding artifacts to disk
async function runPipeline(config, docs) {
    // we need to create the runtime folder structure
    await config.createDirectories();
    // reset the newSchema accumulator
    config.newSchema = '';
    // reset the newDocuments accumulator
    config.newDocuments = '';
    // we need to hold onto some stats for the generated artifacts
    const artifactStats = {
        total: [],
        changed: [],
        new: [],
    };
    // notify the user we are starting the generation process
    if (config.logLevel !== common_1.LogLevel.Quiet) {
        console.log('ðŸŽ© Generating runtime...');
    }
    // the last version the runtime was generated with
    let previousVersion = '';
    try {
        const content = JSON.parse(await promises_1.default.readFile(config.metaFilePath, 'utf-8'));
        previousVersion = content.version;
    }
    catch { }
    // if the previous version is different from the current version
    const versionChanged = previousVersion && previousVersion !== 'HOUDINI_VERSION';
    await (0, common_1.runPipeline)(config, [
        validators.typeCheck,
        validators.uniqueNames,
        validators.noIDAlias,
        transforms.internalSchema,
        transforms.addID,
        transforms.typename,
        // list transform must go before fragment variables
        // so that the mutation fragments are defined before they get mixed in
        transforms.list,
        // paginate transform needs to go before fragmentVariables
        // so that the variable definitions get hashed
        transforms.paginate,
        transforms.fragmentVariables,
        transforms.composeQueries,
        generators.artifacts(artifactStats),
        generators.runtime,
        generators.typescript,
        generators.persistOutput,
        generators.definitions,
        generators.stores,
    ], docs);
    // don't log anything if its quiet
    if (config.logLevel === common_1.LogLevel.Quiet) {
    }
    else if (versionChanged) {
        console.log('ðŸ’£ Detected new version of Houdini. Regenerating all documents...');
        console.log('ðŸŽ‰ Welcome to HOUDINI_VERSION!');
        // if the user is coming from a version pre-15, point them to the migration guide
        const major = parseInt(previousVersion.split('.')[1]);
        if (major < 15) {
            console.log(`â“ For a description of what's changed, visit this guide: https://www.houdinigraphql.com/guides/migrating-to-0.15.0
â“ Don't forget to update your sourceGlob config value if you want to define documents in external files.`);
        }
    }
    else if ([common_1.LogLevel.Summary, common_1.LogLevel.ShortSummary].includes(config.logLevel)) {
        // count the number of unchanged
        const unchanged = artifactStats.total.length - artifactStats.changed.length - artifactStats.new.length;
        // if we have any unchanged artifacts
        if (unchanged > 0) {
            console.log(`ðŸ“ƒ Unchanged: ${unchanged}`);
        }
        if (artifactStats.changed.length > 0) {
            console.log(`âœï¸  Changed: ${artifactStats.changed.length}`);
            if (config.logLevel === common_1.LogLevel.Summary) {
                logFirst5(artifactStats.changed);
            }
        }
        if (artifactStats.new.length > 0) {
            console.log(`âœ¨ New: ${artifactStats.new.length}`);
            if (config.logLevel === common_1.LogLevel.Summary) {
                logFirst5(artifactStats.new);
            }
        }
    }
    else if (config.logLevel === common_1.LogLevel.Full) {
        for (const artifact of artifactStats.total) {
            // figure out the emoji to use
            let emoji = 'ðŸ“ƒ';
            if (artifactStats.changed.includes(artifact)) {
                emoji = 'âœï¸ ';
            }
            else if (artifactStats.new.includes(artifact)) {
                emoji = 'âœ¨';
            }
            // log the name
            console.log(`${emoji} ${artifact}`);
        }
    }
}
exports.runPipeline = runPipeline;
async function collectDocuments(config) {
    // the first step we have to do is grab a list of every file in the source tree
    const sourceFiles = await (0, util_1.promisify)(glob_1.default)(config.sourceGlob);
    // the list of documents we found
    const documents = [];
    // wait for every file to be processed
    await Promise.all(sourceFiles.map(async (filepath) => {
        // read the file
        const contents = await promises_1.default.readFile(filepath, 'utf-8');
        // if the file ends with .svelte, we need to look for graphql template tags
        if (filepath.endsWith('.svelte')) {
            documents.push(...(await findGraphQLTemplates(filepath, contents)));
        }
        // otherwise just treat the file as a graphql file (the whole file contents constitute a graphql file)
        else {
            documents.push({
                filepath,
                document: contents,
            });
        }
    }));
    return await Promise.all(documents.map(async ({ document, filepath }) => {
        try {
            return await processGraphQLDocument(config, filepath, document);
        }
        catch (e) {
            throw {
                ...e,
                filepath,
            };
        }
    }));
}
async function findGraphQLTemplates(filepath, contents) {
    const documents = [];
    let parsedFile;
    try {
        parsedFile = await (0, common_1.parseFile)(contents);
    }
    catch (e) {
        const err = e;
        // add the filepath to the error message
        throw { message: `Encountered error parsing ${filepath}`, description: err.message };
    }
    // we need to look for multiple script tags to support sveltekit
    const scripts = [parsedFile.instance, parsedFile.module]
        .map((script) => (script ? script.content : null))
        .filter(Boolean);
    await Promise.all(scripts.map(async (jsContent) => {
        // @ts-ignore
        // look for any template tag literals in the script body
        svelte.walk(jsContent, {
            enter(node) {
                // if we are looking at the graphql template tag
                if (node.type === 'TaggedTemplateExpression' &&
                    // @ts-ignore
                    node.tag.name === 'graphql') {
                    // @ts-ignore
                    // parse the tag contents to get the info we need
                    const printedDoc = node.quasi.quasis[0].value.raw;
                    documents.push({ document: printedDoc, filepath });
                }
            },
        });
    }));
    // we found every document in the file
    return documents;
}
async function processGraphQLDocument(config, filepath, document) {
    const parsedDoc = graphql.parse(document);
    // look for the operation
    const operations = parsedDoc.definitions.filter(({ kind }) => kind === graphql.Kind.OPERATION_DEFINITION);
    // there are no operations, so its a fragment
    const fragments = parsedDoc.definitions.filter(({ kind }) => kind === graphql.Kind.FRAGMENT_DEFINITION);
    // if there is more than one operation, throw an error
    if (operations.length > 1) {
        throw { filepath, message: 'Operation documents can only have one operation' };
    }
    // we are looking at a fragment document
    else {
        // if there is more than one fragment, throw an error
        if (fragments.length > 1) {
            throw { filepath, message: 'Fragment documents can only have one fragment' };
        }
    }
    // figure out the document kind
    let kind = types_1.ArtifactKind.Fragment;
    if (operations.length === 1) {
        // the document kind depends on the artifact
        // query
        if (operations[0].kind === 'OperationDefinition' && operations[0].operation === 'query') {
            kind = types_1.ArtifactKind.Query;
        }
        // mutation
        else if (operations[0].kind === 'OperationDefinition' &&
            operations[0].operation === 'mutation') {
            kind = types_1.ArtifactKind.Mutation;
        }
        // subscription
        else if (operations[0].kind === 'OperationDefinition' &&
            operations[0].operation === 'subscription') {
            kind = types_1.ArtifactKind.Subcription;
        }
    }
    // add it to the list
    return {
        name: config.documentName(parsedDoc),
        kind,
        document: parsedDoc,
        filename: filepath,
        originalDocument: parsedDoc,
        generateArtifact: true,
        generateStore: true,
        originalString: document,
    };
}
function logFirst5(values) {
    // grab the first 5 changed documents
    for (const artifact of values.slice(0, 5)) {
        console.log(`    ${artifact}`);
    }
    // if there are more than 5 just tell them how many
    if (values.length > 5) {
        console.log(`    ... ${values.length - 5} more`);
    }
}
