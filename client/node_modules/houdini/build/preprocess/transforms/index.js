"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// externals
const recast = __importStar(require("recast"));
// locals
const common_1 = require("../../common");
const fragment_1 = __importDefault(require("./fragment"));
const query_1 = __importDefault(require("./query"));
const mutation_1 = __importDefault(require("./mutation"));
const subscription_1 = __importDefault(require("./subscription"));
const defaultTransforms = [
    fragment_1.default,
    query_1.default,
    mutation_1.default,
    subscription_1.default,
];
async function applyTransforms(config, doc, pipeline = defaultTransforms) {
    // a single transform might need to do different things to the module and
    // instance scripts so we're going to pull them out, push them through separately,
    // and then join them back together
    const scripts = await (0, common_1.parseFile)(doc.content);
    // wrap everything up in an object we'll thread through the transforms
    const result = {
        instance: scripts.instance,
        module: scripts.module,
        config,
        dependencies: [],
        filename: doc.filename,
    };
    // send the scripts through the pipeline
    await (0, common_1.runPipeline)(config, pipeline, result);
    // we need to apply the changes to the file. we'll do this by printing the mutated
    // content as a string and then replacing everything between the appropriate
    // script tags. the parser tells us the locations for the different tags so we
    // just have to replace the indices it tells us to
    const printedModule = result.module ? recast.print(result.module.content).code : '';
    const printedInstance = result.instance
        ? recast.print(result.instance.content).code
        : '';
    // if there is a module and no instance
    if (result.module && !result.instance) {
        // just copy the module where it needs to go
        return {
            code: replaceTagContent('module', doc.content, result.module.start, result.module.end, printedModule),
            dependencies: result.dependencies,
        };
    }
    // if there is an instance and no module
    if (result.instance && !result.module) {
        // the instance is lower than the module
        // just copy the instance where it needs to go
        return {
            code: replaceTagContent('instance', doc.content, result.instance.start, result.instance.end, printedInstance),
            dependencies: result.dependencies,
        };
    }
    // if we still don't have any javascript on this page
    if (!result.module || !result.instance) {
        // ignore it
        return {
            code: doc.content,
            dependencies: [],
        };
    }
    // there is both a module and an instance so we want to replace the lowest
    // one first so that the first's indices stay valid after we change content
    // if the module is lower than the instance
    if (result.module.end > result.instance.end) {
        // replace the module content first
        const updatedModule = replaceTagContent('module', doc.content, result.module.start, result.module.end, printedModule);
        return {
            code: replaceTagContent('instance', updatedModule, result.instance.start, result.instance.end, printedInstance),
            dependencies: result.dependencies,
        };
    }
    // replace the instance content first (so the module indices are valid)
    const updatedInstance = replaceTagContent('instance', doc.content, result.instance.start, result.instance.end, printedInstance);
    // then replace the module content
    return {
        code: replaceTagContent('module', updatedInstance, result.module.start, result.module.end, printedModule),
        dependencies: result.dependencies,
    };
}
exports.default = applyTransforms;
function replaceTagContent(context, source, start, end, insert) {
    // if we're supposed to insert the tag
    if (start === 0 && end === 0) {
        // make sure to define the right context
        const attrs = context === 'module' ? ' context="module"' : '';
        // just add the script at the start
        return `<script${attrs}>${insert}</script>${source}`;
    }
    const [greaterThanIndex, lessThanIndex] = (0, common_1.findScriptInnerBounds)({ start, end, text: source });
    // replace the content between the closing of the open and open of the close
    return replaceBetween(source, greaterThanIndex, lessThanIndex, insert);
}
// replaceSubstring replaces the substring string between the indices with the provided new value
const replaceBetween = (origin, startIndex, endIndex, insertion) => origin.substring(0, startIndex) + insertion + origin.substring(endIndex);
