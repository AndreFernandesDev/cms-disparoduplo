"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogLevel = exports.getConfig = exports.readConfigFile = exports.Config = void 0;
const schema_1 = require("@graphql-tools/schema");
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = require("glob");
const graphql = __importStar(require("graphql"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const url = __importStar(require("url"));
// locals
const lib_1 = require("../runtime/lib");
const types_1 = require("../runtime/lib/types");
// a place to hold conventions and magic strings
class Config {
    constructor({ filepath, loadFrameworkConfig, ...configFile }) {
        this.framework = 'kit';
        this.module = 'esm';
        this.newSchema = '';
        this.newDocuments = '';
        this.defaultKeys = ['id'];
        this.configIsRoute = null;
        this.configFile = (0, lib_1.defaultConfigValues)(configFile);
        // apply defaults and pull out the values
        let { schema, schemaPath, sourceGlob, apiUrl, quiet = false, framework = 'kit', module = 'esm', static: staticSite, scalars, cacheBufferSize, definitionsPath, defaultCachePolicy = types_1.CachePolicy.CacheOrNetwork, defaultPartial = false, defaultKeys, types = {}, logLevel, disableMasking = false, routesDir = null, } = this.configFile;
        // make sure we got some kind of schema
        if (!schema) {
            throw {
                filepath,
                message: 'Invalid config file: please provide one of schema or schemaPath. Also, export default config',
            };
        }
        // if we're given a schema string
        if (typeof schema === 'string') {
            this.schema = graphql.buildSchema(schema);
        }
        else {
            this.schema = schema;
        }
        // validate the log level value
        if (logLevel && !Object.values(LogLevel).includes(logLevel.toLowerCase())) {
            console.warn(`⚠️ Invalid log level provided. Valid values are: ${JSON.stringify(Object.values(LogLevel))}`);
            logLevel = LogLevel.Summary;
        }
        if (framework === 'sapper') {
            console.warn(`⚠️ Support for sapper will be dropped in 0.16.0. ⚠️
If that's going to be a problem, please open a discussion on GitHub.`);
        }
        // save the values we were given
        this.schemaPath = schemaPath;
        this.apiUrl = apiUrl;
        this.filepath = filepath;
        this.sourceGlob = sourceGlob;
        this.framework = framework;
        this.module = module;
        this.projectRoot = path_1.default.dirname(filepath);
        this.static = staticSite;
        this.scalars = scalars;
        this.cacheBufferSize = cacheBufferSize;
        this.defaultCachePolicy = defaultCachePolicy;
        this.defaultPartial = defaultPartial;
        this.definitionsFolder = definitionsPath;
        this.logLevel = (logLevel || LogLevel.Summary).toLowerCase();
        this.disableMasking = disableMasking;
        this.routesDir = routesDir;
        // if the user asked for `quiet` logging notify them its been deprecated
        if (quiet) {
            console.warn(`⚠️ The quiet configuration parameter has been deprecated. ⚠️
You should update your config to look like this:

export default {
    // ...
    logLevel: 'quiet'
}


For more information, visit this link: https://www.houdinigraphql.com/guides/migrating-to-0.15.0#config-values
`);
            this.logLevel = LogLevel.Summary;
        }
        // hold onto the key config
        if (defaultKeys) {
            this.defaultKeys = defaultKeys;
        }
        if (types) {
            this.typeConfig = {
                ...this.typeConfig,
                ...types,
            };
        }
        // if we are building a sapper project, we want to put the runtime in
        // src/node_modules so that we can access @sapper/app and interact
        // with the application stores directly
        this.rootDir =
            framework === 'sapper'
                ? path_1.default.join(this.projectRoot, 'src', 'node_modules', '$houdini')
                : path_1.default.join(this.projectRoot, '$houdini');
        // if the config file specified an isRoute, use that
        if (configFile.routes) {
            this.configIsRoute = configFile.routes;
        }
    }
    // compute if a path points to a component query or not
    isRoute(filepath) {
        // a vanilla svelte app is never considered in a route
        if (this.framework === 'svelte' || this.static) {
            return false;
        }
        // only consider filepaths in src/routes
        const routesDir = this.routesDir || 'src/routes';
        if (!posixify(filepath).startsWith(posixify(path_1.default.join(this.projectRoot, routesDir)))) {
            return false;
        }
        // always consider layouts as routes
        if (layout_pattern.test(path_1.default.parse(filepath).name)) {
            return true;
        }
        // if there is a route function from the config
        if (this.configIsRoute) {
            return this.configIsRoute(filepath);
        }
        // there is no special filter to apply. anything this far is a route
        return true;
    }
    async loadKitConfig({ isRoute, configFilePath, }) {
        // if we fail to load
        try {
            // so far, all this does is load the route function so if we don't
            // have to do that, we're done
            if (!isRoute) {
                return;
            }
            // import the user's kit config file, and look for a custom isRoute function
            const configFile = path_1.default.join(process.cwd(), configFilePath || 'svelte.config.js');
            const config = await Promise.resolve().then(() => __importStar(require(url.pathToFileURL(configFile).href)));
            // if there is a custom route function, use it
            if (config.routes) {
                this.configIsRoute = config.routes;
            }
        }
        catch { }
        // if its not in the route directory, its not a
        // if we didn't assign an isRoute function, use the default kit one
        if (!this.configIsRoute) {
            // copied from here: https://github.com/sveltejs/kit/blob/28139749c4bf056d1e04f55e7f955da33770750d/packages/kit/src/core/config/options.js#L250
            this.configIsRoute = (filepath) => !/(?:(?:^_|\/_)|(?:^\.|\/\.)(?!well-known))/.test(filepath);
        }
    }
    /*

        Directory structure

    */
    // the directory where we put all of the artifacts
    get artifactDirectory() {
        return path_1.default.join(this.rootDir, this.artifactDirectoryName);
    }
    get artifactDirectoryName() {
        return 'artifacts';
    }
    // the directory where artifact types live
    get artifactTypeDirectory() {
        return this.artifactDirectory;
    }
    // the directory where we put all of the stores
    get storesDirectory() {
        return path_1.default.join(this.rootDir, this.storesDirectoryName);
    }
    get metaFilePath() {
        return path_1.default.join(this.rootDir, 'meta.json');
    }
    get storesDirectoryName() {
        return 'stores';
    }
    // where we will place the runtime
    get runtimeDirectory() {
        return path_1.default.join(this.rootDir, 'runtime');
    }
    // Default to => $houdini/graphql
    get definitionsDirectory() {
        return this.definitionsFolder
            ? path_1.default.join(this.projectRoot, this.definitionsFolder)
            : path_1.default.join(this.rootDir, 'graphql');
    }
    get enumRuntimeDefinitionsPath() {
        return path_1.default.join(this.definitionsDirectory, 'enums.js');
    }
    get enumTypesDefinitionsPath() {
        return path_1.default.join(this.definitionsDirectory, 'enums.d.ts');
    }
    get definitionsSchemaPath() {
        return path_1.default.join(this.definitionsDirectory, 'schema.graphql');
    }
    get definitionsDocumentsPath() {
        return path_1.default.join(this.definitionsDirectory, 'documents.gql');
    }
    get typeIndexPath() {
        return path_1.default.join(this.rootDir, 'index.d.ts');
    }
    artifactTypePath(document) {
        return path_1.default.join(this.artifactTypeDirectory, `${this.documentName(document)}.d.ts`);
    }
    // the location of the artifact generated corresponding to the provided documents
    artifactPath(document) {
        // use the operation name for the artifact
        // make sure to mark artifacts as .js in sveltekit
        return path_1.default.join(this.artifactDirectory, this.documentName(document) + '.js');
    }
    // the path that the runtime can use to import an artifact
    artifactImportPath(name) {
        return `$houdini/${this.artifactDirectoryName}/${name}`;
    }
    // the path that the runtime can use to import a store
    storeImportPath(name) {
        return `$houdini/${this.storesDirectoryName}/${name}`;
    }
    storeName({ name }) {
        return `GQL_${name}`;
    }
    storeFactoryName(name) {
        return name + 'Store';
    }
    keyFieldsForType(type) {
        return (0, lib_1.keyFieldsForType)(this.configFile, type);
    }
    computeID(type, data) {
        return (0, lib_1.computeID)(this.configFile, type, data);
    }
    // a string identifier for the document (must be unique)
    documentName(document) {
        // if there is an operation in the document
        const operation = document.definitions.find(({ kind }) => graphql.Kind.OPERATION_DEFINITION);
        if (operation) {
            // if the operation does not have a name
            if (!operation.name) {
                // we can't give them a file
                throw new Error('encountered operation with no name: ' + graphql.print(document));
            }
            // use the operation name for the artifact
            return operation.name.value;
        }
        // look for a fragment definition
        const fragmentDefinitions = document.definitions.filter(({ kind }) => kind === graphql.Kind.FRAGMENT_DEFINITION);
        if (fragmentDefinitions.length) {
            // join all of the fragment definitions into one
            return fragmentDefinitions.map((fragment) => fragment.name).join('_');
        }
        // we don't know how to generate a name for this document
        throw new Error('Could not generate artifact name for document: ' + graphql.print(document));
    }
    isSelectionScalar(type) {
        return ['String', 'Boolean', 'Float', 'ID', 'Int']
            .concat(Object.keys(this.scalars || {}))
            .includes(type);
    }
    async createDirectories() {
        await Promise.all([
            fs_extra_1.default.mkdirp(this.artifactDirectory),
            fs_extra_1.default.mkdirp(this.artifactTypeDirectory),
            fs_extra_1.default.mkdirp(this.runtimeDirectory),
            fs_extra_1.default.mkdirp(this.storesDirectory),
            fs_extra_1.default.mkdirp(this.definitionsDirectory),
        ]);
    }
    /*

        GraphqQL conventions

    */
    get listDirective() {
        return 'list';
    }
    get listPrependDirective() {
        return 'prepend';
    }
    get listAppendDirective() {
        return 'append';
    }
    get listParentDirective() {
        return this.listDirectiveParentIDArg;
    }
    get listDirectiveParentIDArg() {
        return 'parentID';
    }
    get listNameArg() {
        return 'name';
    }
    get insertFragmentSuffix() {
        return `_insert`;
    }
    get removeFragmentSuffix() {
        return `_remove`;
    }
    get toggleFragmentSuffix() {
        return `_toggle`;
    }
    get deleteDirectiveSuffix() {
        return `_delete`;
    }
    get whenDirective() {
        return 'when';
    }
    get whenNotDirective() {
        return this.whenDirective + '_not';
    }
    get argumentsDirective() {
        return 'arguments';
    }
    get withDirective() {
        return 'with';
    }
    get paginateDirective() {
        return 'paginate';
    }
    get paginateNameArg() {
        return 'name';
    }
    get cacheDirective() {
        return 'cache';
    }
    get cachePartialArg() {
        return 'partial';
    }
    get cachePolicyArg() {
        return 'policy';
    }
    paginationQueryName(documentName) {
        return documentName + '_Pagination_Query';
    }
    isDeleteDirective(name) {
        return name.endsWith(this.deleteDirectiveSuffix);
    }
    listDeleteDirective(name) {
        return name + this.deleteDirectiveSuffix;
    }
    deleteDirectiveType(name) {
        return name.slice(0, name.length - this.deleteDirectiveSuffix.length);
    }
    isInsertFragment(name) {
        return name.endsWith(this.insertFragmentSuffix);
    }
    listInsertFragment(name) {
        return name + this.insertFragmentSuffix;
    }
    listToggleFragment(name) {
        return name + this.toggleFragmentSuffix;
    }
    isRemoveFragment(name) {
        return name.endsWith(this.removeFragmentSuffix);
    }
    isToggleFragment(name) {
        return name.endsWith(this.toggleFragmentSuffix);
    }
    listRemoveFragment(name) {
        return name + this.removeFragmentSuffix;
    }
    isInternalEnum(node) {
        // if we are looking at an enum, it could be CachePolicy
        return node.name.value === 'CachePolicy';
    }
    isInternalDirective({ name }) {
        return ([
            this.listDirective,
            this.listPrependDirective,
            this.listAppendDirective,
            this.listDirectiveParentIDArg,
            this.whenDirective,
            this.whenNotDirective,
            this.argumentsDirective,
            this.withDirective,
            this.paginateDirective,
            this.cacheDirective,
        ].includes(name.value) || this.isDeleteDirective(name.value));
    }
    isListFragment(name) {
        return (name.endsWith(this.insertFragmentSuffix) ||
            name.endsWith(this.removeFragmentSuffix) ||
            name.endsWith(this.toggleFragmentSuffix));
    }
    isListOperationDirective(name) {
        return name.endsWith(this.deleteDirectiveSuffix);
    }
    isFragmentForList(listName, fragmentName) {
        return fragmentName.startsWith(listName);
    }
    // return 'insert' for All_Users_insert
    listOperationFromFragment(fragmentName) {
        // check the name against the fragment patterns
        if (this.isInsertFragment(fragmentName)) {
            return 'insert';
        }
        else if (this.isRemoveFragment(fragmentName)) {
            return 'remove';
        }
        else if (this.isToggleFragment(fragmentName)) {
            return 'toggle';
        }
        throw new Error('Could not determine list operation from fragment name: ' + fragmentName);
    }
    listNameFromDirective(directiveName) {
        try {
            return this.listNameFromFragment(directiveName);
        }
        catch (e) {
            throw new Error('Could not find list name from directive: ' + directiveName);
        }
    }
    listNameFromFragment(fragmentName) {
        // starting at the end of the fragment name going left, look for a _
        for (let i = fragmentName.length - 1; i >= 0; i--) {
            // if we hit a _
            if (fragmentName[i] === '_') {
                return fragmentName.substr(0, i);
            }
        }
        throw new Error('Could not find list name from fragment: ' + fragmentName);
    }
}
exports.Config = Config;
const DEFAULT_CONFIG_PATH = path_1.default.join(process.cwd(), 'houdini.config.js');
// helper function to load the config file
async function readConfigFile(configPath = DEFAULT_CONFIG_PATH) {
    // on windows, we need to prepend the right protocol before we
    // can import from an absolute path
    let importPath = configPath;
    if (os_1.default.platform() === 'win32') {
        importPath = 'file:///' + importPath;
    }
    const imported = await Promise.resolve().then(() => __importStar(require(importPath)));
    // if this is wrapped in a default, use it
    const config = imported.default || imported;
    return config;
}
exports.readConfigFile = readConfigFile;
// a place to store the current configuration
let _config;
async function loadSchemaFile(schemaPath) {
    // if the schema is not a relative path, the config file is out of date
    if (path_1.default.isAbsolute(schemaPath)) {
        // compute the new value for schema
        const relPath = path_1.default.relative(process.cwd(), schemaPath);
        // build up an error with no stack trace so the message isn't so noisy
        const error = new Error(`Invalid config value: 'schemaPath' must now be passed as a relative directory. Please change ` +
            `its value to "./${relPath}".`);
        error.stack = '';
        // don't let anything continue
        throw error;
    }
    // if the path is a glob, load each file
    if (glob_1.glob.hasMagic(schemaPath)) {
        // the first step we have to do is grab a list of every file in the source tree
        const sourceFiles = await (0, util_1.promisify)(glob_1.glob)(schemaPath);
        return (0, schema_1.mergeSchemas)({
            typeDefs: await Promise.all(sourceFiles.map(async (filepath) => fs_extra_1.default.readFile(filepath, 'utf-8'))),
        });
    }
    // the path has no glob magic, make sure its a real file
    if (!fs_extra_1.default.stat(schemaPath)) {
        throw new Error(`Schema file does not exist! Create it using houdini generate -p`);
    }
    const contents = await fs_extra_1.default.readFile(schemaPath, 'utf-8');
    // if the schema points to an sdl file
    if (schemaPath.endsWith('gql') || schemaPath.endsWith('graphql')) {
        return graphql.buildSchema(contents);
    }
    // the schema must point to a json blob (with data level or content of data directly)
    const jsonContents = JSON.parse(contents);
    if (jsonContents.data) {
        return graphql.buildClientSchema(jsonContents.data);
    }
    return graphql.buildClientSchema(jsonContents);
}
// get the project's current configuration
async function getConfig({ configFile, ...extraConfig } = {}) {
    if (_config) {
        return _config;
    }
    // add the filepath and save the result
    const configPath = configFile || DEFAULT_CONFIG_PATH;
    const config = await readConfigFile(configPath);
    // look up the schema
    let schema = config.schema;
    if (config.schemaPath) {
        schema = await loadSchemaFile(config.schemaPath);
    }
    _config = new Config({
        schema,
        ...config,
        ...extraConfig,
        filepath: configPath,
    });
    // if we are loading a sveltekit project, we might be able to grab the isRoute
    // from the config (if it exists)
    if (config.framework === 'kit') {
        // only load the route config if the user didn't specify one explicitly
        await _config.loadKitConfig({
            isRoute: !config.routes,
            configFilePath: config.frameworkConfigFile,
        });
    }
    return _config;
}
exports.getConfig = getConfig;
var LogLevel;
(function (LogLevel) {
    LogLevel["Full"] = "full";
    LogLevel["Summary"] = "summary";
    LogLevel["ShortSummary"] = "short-summary";
    LogLevel["Quiet"] = "quiet";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
const posixify = (str) => str.replace(/\\/g, '/');
const layout_pattern = /^__layout(?:-([a-zA-Z0-9_-]+))?(?:@([a-zA-Z0-9_-]+))?$/;
